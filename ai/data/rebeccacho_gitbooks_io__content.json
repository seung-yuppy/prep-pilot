[
  {
    "chapter": 1,
    "title": "2. 변수",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter2.html",
    "content": "단 하나의 값을 저장할 수 있는 메모리 공간\n1.2 변수의 선언과 초기화\n메모리의 빈 공간에 변수타입에 알맞은 크기의 저장공간이 확보되고 앞이로 이 저장공간은 변수이름을 통해 사용 가능\n변수를 사용하기 전에 처음으로 값을 저장하는 것\nint a, b; // 변수의 타입이 같은 경우 콤마,를 구분자로 한 줄에 선언 가능\nint x = 0, y = 0;\n두 변수의 값 교환하기\nint x = 10;\nint y = 20;\nint tmp; // x값을 임시로 저장할 변수를 이용\n변수의 이름처럼 프로그래밍에서 사용하는 모든 이름\n식별자를 만들 때 규칙 4\n대소문자가 구분되며 길이에 제한이 없다.\n예약어를 사용해서는 안 된다.\n숫자로 시작해서는 안 된다.\n특수문자는 _와 만을 허용한다.\n키워드(keyword) 또는 리져브드 위드(reserved word)라고 하며 프로그래밍 언어의 구문에 사용\n변수 명명 권장 사항\n클래스 이름의 첫 글자는 항상 대문자로 한다.\n변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.\n여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.\n상수의 이름은 모두 대문자로 한다.\n여러 단어로 이루어진 경우 _로 구분한다.\n어떤 값이 저장되어 있는 주소(memory address)를 값으로 저장\n클래스 이름 변수이름; // 변수의 타입이 클래스 이름인 것들은 모두 참조변수이다.\n참조형 변수를 구분할 때 타입(type)이라는 용어를 사용하며 기본형 변수는 자료형(data type) 이라는 용어를 사용.\n타입(type)이 자료형(data type)을 포함하는 보다 넓은 의미\n모두 8개의 타입이 있으며 크게 논리형, 문자형, 정수형, 실수형으로 구분\ntrue와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용\n다른 기본형과의 연산이 불가능\n문자를 저장하는데 사용되며, 변수 당 하나의 문자만 저장 가능\n정수형(byte, short, int, long)\n정수 값을 저장하는 데 사용하며, 주로 int와 long이 사용\n타입의 크기: byte=1byte, short=2byte, int=4byte, double=8byte\n값의 범위: -2ⁿ¹  2ⁿ¹ -1(n: bit수)\nint타입의 변수는 대략 10자리 수, long타입의 변수는 19자리 수\nbyte는 이진 데이터를 다루는데 주로 사용\nshort는 C언어와의 호환을 위해서 추가\n실수를 저장하는데 사용되며, 주로 double 사용\n타입의 크기: float=4byte, double=8byte\n정수형과 저장형식이 달라서 같은 크기라도 훨씬 큰 값을 표현할 수 있으나 오차가 발생할 수 있는 단점이 있음\n정밀도에 따라 오차의 범위가 달라짐\n2.2 상수와 리터럴(constant  literal)\n변수와 마찬가지로 '값을 저장할 수 있는 공간'\n변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없음\n변수와 선언하는 법은 동일하며, 타입 앞에  'final'키워드를 붙임\n선언과 동시에 초기화 해야하며, 그 후 부터는 상수의 값 변경 불가\n이름은 모두 대무자로 하는 것이 관례이며, 여러 단어로 이루어진 경우 '_'로 구분\n12, 123, 'A'와 같은 기존 '상수'의 다른 이름\n리터럴에 '의미있는 이름'을 붙여서 코드의 이해와 수정을 도움\n논리형: false, true / 접미사 없음\n정수형: 123,0b0101, 077, 0xFF, 100L / L\nlong타입의 리터럴에 접미사 'l' 또는 'L'을 붙임\nlong big = 100_000_000_000L; // 100000000000L;\nbyte와 short타입의 변수에 값을 저장할 때는 int타입의 리터럴 사용\n10진수 외에 2, 8, 16진수로 표현된 리터럴을 변수에 저장 가능\n16진수: 접두사 '0x' or '0X'\n2진수: 접두사 '0b'or '0B'(JDK 1.7부터)\nJDK 1.7부터 정수형 리터럴 중간에 구분자 '_'를 넣을 수 있어서 큰 숫자 읽을 때 용이\n실수형: 3.14, 3.0e8, 1.4f, 0x1.0p-1 / f, d\nfloat타입에 접미사 'f' or 'F'\ndouble타입에 접미사 'd' or 'D'(실수형의 기본 자료형으로 생략 가능)\n리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e, 그리고 접미사 f, F, d, D 포함시에 실수형 리터럴로 간주\n16진 지수 형태 표현: p or P(2의 제곱을 의미)\n왼쪽에 16진수를 적고 오른쪽에 지수를 10진수 정수로 적음: 0x1p1 = (1\n21 = 1.0 * 2 = 2.0\n문자형: 'A', '1' / 접미사 없음\n문자열: \"ABC\" / 접미사 없음\n타입이 달라도 저장 범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용\nlong l = 123; // long > int\n문자 리터럴과 문자열 리터럴\n작은 따옴표로 문자 하나를 감싼 것\nchar변수는 단 하나의 문자만 저장 가능\nchar ch = ''; // error\nchar ch = ' '; // ok, 공백문자로 초기화\n큰 따옴표로 감싼 것\n\"\" 안에 아무런 문자도 넣지 않는 것 허용\nString name = new String(\"Java\");\nString name = \"Ja\" + \"va\";\n+은 피연산자 중 어느 한쪽이 String이면 나머지 한쪽을 먼저 String으로 변환 후 결합\nString str = name + 8.0;\n2.3 형식화된 출력 - printf()\n'지시자(specifier)'를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력\n출력 후 줄바꿈 없음(줄바꿈 지시자: n)\n자주 사용되는 printf의 지시자\nint finger = 10;\nprintf(\"finger=[5d]n\", finger);  // finger=[   10]\nprintf(\"finger=[-5d]n\", finger); // finger=[10   ]\nprintf(\"finger=[05d]n\", finger); // finger=[00010]\nchar c = 'A';\nprintf(\"c=c, dn\", c, (int)c); // 형변환이 꼭 필요\nint octNum = 010;\nprintf(\"octNum=o, n\", octNum);  // octNum=10, 010\nint hexNum = 0x10;\nprintf(\"hexNum=x, n\", hexNum); // hexNum=10, 0x10\n소수점 이하 6자리까지만 출력하며 소수점 이하 7자리에서 반올림 (1.23456789 = 1.234568)\n전체 자리수와 소수점 이하 자리수 지정\nint binNum = ob10; // 2진수 10\nprintf(\"binNum=sn\", Integer.toBinaryString(binNum)); // binNum=10\n숫자를 추가하면 원하는 만큼의 출력공간을 확보하거나 문자열의 일부만 출력 가능\n2.4 화면에서 입력받기 - Scanner\n*; // Scanner클래스를 사용하기 위해 추가\nScanner scanner = new Scanner(System.in);\nString input = scanner.nextLine(); // 입력대기 상태에 있다가 입력 후 엔터키를 누르면 입력한 내용이 문자열로 반환\nint num = Integer.parseInt(input); // 문자열을 int타입의 정수로 변환\nint num = scanner.nextInt(); // 정수를 입력 받음\n한 자리의 2진수로 컴퓨터가 값을 저장할 수 있는 최소단위\n1비트 8개를 묶어서 데이터의 기본 단위로 사용\nCPU가 한번에 처리할 수 있는 데이터의 크기\nCPU의 성능에 따라 32비트 CPU에서 1워드는 32비트(4바이트) / 64비트 CPU에서는 64비트(8바이트)\nn비트로 표현할 수 있는 10진수\n값의 범위: 0  2ⁿ-1\n16진법: 0  9, A  F\n2진수를 8진수, 16진수로 변환\n2진수를 뒤에서부터 3자리씩 끊어서 그에 해당하는 8진수로 변환\n2진수를 뒤에서부터 4자리씩 끊어서 그에 해당하는 16진수로 변환\n3.4 정수의 진법 변환\n2 를 반복해서 나머지를 순서대로 이으면 2진법 숫자로 바뀜\n3.5 실수으 진법 변환\n10진 소수점수를 2진 소수점수로 변환하는 방법\n1) 10진 소수에 2를 곱한다\n2) 위의 결과에서 소수부만 가져다가 다시 2를 곱한다\n3) 1) 2) 과정을 소수부가 0이 될때까지 반복한다.\n곱한 결과의 정수부만 순서대로 나열하면 2진 소수ㅈ값이 나온다ㅏ.\n3.6 음수의 2진 표현 - 2의 보수법\n왼쪽의 첫 번째 비트가 0인면 양수, 1이면 음수다.\n1001 을 -1로 해석하는 방식이 있고, 1001을 -7로 해석하는 방식이 있다.\n1001을 -7로 해석하는 방식을 2의 보수법이라고 한다.\n양수와 음수를 더했을 때 2진수로 같은 결과를 얻으므로 부호를 신경쓰지 않고 덧셈할 수 있게 된다.\n그리고 2진수가 증가할 때 10진 음수가 감소한다는모순도 없어진다.\n2으이 보수를 구하는 방법은\n2의 보수 = 1의 보수 + 1\n4.1 논리형 - boolean\ntrue, false 중 하나를 저장할 수 있으며기본값은 fals\n대문자 True, False는 에러다\n4.2 문자형 - char\nchar ch = 'A';\n위의 문장은 변수에 문자가 저장되는 것 같지만, 사실은 문자가 아닌  '문자의 유니코드 정수'가 저장된다.\nchar ch = 65;\n// 위 둘은 동일한 결과\n아스키는 128개 문자 집합 7비트 부호\n확장 아스키에 추가된 128개의문자는 여러 국가와 기업에서 서로의 필요에 따라 다르게 정의해서 사용한다.\n그 중에서 대표적인것이 ISO-8859-1이다.\n이 확장 아스키 버전은 ISO Latin 1 이라고도 하는데 서유럽에서 일반적으로 사용하는 문자들을 포함하고 있다.\n한글을 표현하는 방법은 조합형과 완성형이 있는데, 조합형은 초성 중성 종성을 조합하는 방식이고 완성형은 확장 아스키의 일부 영역에 해당하는 두 문자코드를 조합해서 한글을 표현한다.\n요즘은 완성형에 없는 잘 안쓰는 8822글자를 추가한 확장 완성형 CP 949이 사용되는데, 이것이 바로 한글 윈도우에서 사용하는 문자 인코딩이다.\nIBM에서 자사의 PC에 확장 아스키를 도입하기 시작할 때, 국가에 따라 어려 버전의 확장 아스키가 필요했다.\nIBM은 이를 Code Page라 했다.\n한글 윈도우는 CP 949, 영문 윈도우는 CP 437을 사용한다.\n예전엔 같은 지역 내에서만 문서교환이 주를 이뤘지만,.\n인터넷 시대에서 여러 나라에서 문서를 주고받을 때 이를 통합하려는 노력으로 유니코드가 생겼다.\n유니코드 인코딩에는 UTF-8, UTF-16, UTF-32 등 여러가지 종류가 있는데, 자바에서는 UTF-16을 사용한다.\nUTF-16은 모든 문자를 2바이트로 동일하게 표현하는 반면, UTF-8은 영어 숫자는 1바이트, 한글은 3바이트를 사용한 가변 방식으로 표현한다.\n인터넷에선 요즘 UTF-8 문서가 빠르게 늘어나고 있다.\n정수형은 byte, short보다 int를 사용해라\nJVM의 피연산자 스택이 피연산자를 4바이트 단위로 저장하기 때문에 4바이트보다 작은 자료형의 값을 계산할 때는 4바이트로 변환하여 연산이 수행된다.\n그래서 오히려 int를 사용하는 것이 더 효율적이다.\n정수형 변수를 선언할 때는 int 타입으로 하고 int의 범위(약 20억)을 넘어서는 수를 다뤄야 할 때는 long을 사용하면 된다.\n그리고 byte, short는 성능보다 저장공간 절약할 때 쓰도록 하자.\n오버플로우가 발생한다고 에러가 발생하지는 않는다.\n그러니 적절한 변수형을 사용하자.\n형변환이란 변수 또는 상수의 타입을 다른 타입으로 변환하는 것\n큰 타입에서 작은 타입으로 변환시 값 손실이 발생할 수 있다.\nfloat 타입의 범위를 넘는 값을 float으로 변환하면 무한대 또는 0을 결과로 얻는다.\n5.5 정수형과 실수형 간의 형변환\n서로 다른 타입간의 대입이나 연산을 할 때 형변환으로 타입을 일치시키는 것이 원칙이지만 생략도 가능하다.\n1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.\n기본형과 참조형은 서로 형변환할 수 없다.\n서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다."
  },
  {
    "chapter": 2,
    "title": "3. 연산자",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter3.html",
    "content": "연산을 수행하는 기호(+, -, *, /)\n연산자의 작업 대상(변수, 상수, 리터럴, 수식)\n연산자와 피연산자를 조합하여 계산하는 표현\n= Simple assignment operator\n+= Add AND assignment operator\n-= Subtract AND assignment operator\n*= Multiply AND assignment operator\n/= Divide AND assignment operator\n= Modulus AND assignment operator\n<<= , >>=, =, =, =\n// a = a + 1\n// a = a/1\n// a = a << 1\n+, -, *, /, , ++, --\n==, !=, >, <, >=, <=\n, , , , <<, >>, >>>\n3.1.4 연산자의 우선순위와 결합규칙\n\"1 + 2 = \"\n두 피연산자의 타입을 같게 일치(큰 타입으로)\n피연산자 타입이 int보다 작으면 int로 변환\nex) 5/2 -> 2(정수형) //소수점 이하 버림\nex2) 5.0/2 -> 2.5(실수형) //2가 실수형으로 자동 형변환\n3.2.1 증감 연산자 ++ --\nz = ++x * y--;\n3.2.2 부호 연산자 + -\n3.3.1 사칙 연산자 + - * /\n연산결과로 형변환이 일어날 수 있다.\n큰 타입 -> 작은 타입 : 데이터 손실이 일어날 수 있다.\nex) int -> long\n작은 타입 -> 큰 타입 : 데이터 손실이 일어나지 않는다.\nex) int -> byte\n피연산자들을 나누고 난 나머지 값\nEX) 108 ==> 10-8\n비교연산자는 2항 연산자로 비교연산자의 좌항과 우항을 비교하며 그 결과는 true 혹은 false 중 하나가 된다.\n만약 좌항과 우항의 타입이 다르면 자료형의 범위가 큰 쪽으로 형변환된 후 비교한다\n3.4.1 대소비교 연산자 < > <= >=\n기본 자료형 중 boolean을 제외한 나머지 자료형의 값을 비교한다.\n클래스와 같은 참조형은 비교할 수 없다.\n> 왼쪽이 크면 true, 오른쪽이 크면 false\n< 왼쪽이 크면 false, 오른쪽이 크면 true\n>= 왼쪽이 크면 true, 오른쪽이 크면 false.\n또 왼쪽과 오른쪽이 같으면 true\n<= 왼쪽이 크면 false, 오른쪽이 크면 true.\n그렇다면 어떤 비교 연산자를 사용해야 코드 가독성이 좋아질까?\n3.4.2 등가비교 연산자 == !=\n등가비교 연산자는 2항 연산자이다.\n대소비교 연산자와 달리 크기를 비교하지않고 값이 같은지 혹은 다른지를 검사한다.\n대소비교는 기본 자료형만 가능하나, 등가비교는 클래스와 같은 참조형의 비교도 가능하다.\n기본 자료형은 변수에 저장된 값을 비교하고, 참조형은 객체의 주소값을 저장하고 있으므로 동일한 객체를 가리키는지를 비교하게 된다.\n== 두 값이 같으면 true, 다르면 false\n!= 두 값이 같으면 false, 다르면 true\n비교연산자의 피항의 타입이 다를 경우 자료형의 범위가 다를 경우 큰 쪽으로 형변환 후 비교연산을 수행하므로 아래 결과에 주의하기 바란다.\n단 기본자료형과 참조형을 비교할 순 없다.\n참조형인 String 타입의 문자열을 비교할 때 주의할 점이 있다.\nfoo 메소드 호출하며 인자로 \"sample\"을 전달한 것과 new String(\"sample\")을 전달한 결과가 다르다.\n\"sample\"과 같이 String 타입의 값을 만드는 리터럴을 사용해 만들어진 객체는 컴파일러에 의해 동일한 객체를 가리키고 있기 때문이다.\n\"sample\"==\"sample\"은 값을 비교한게 아니라 컴파일러에 의해 만들어진 동일한 객체를 비교한 것임을 명심하자.\n원리는 알았으니 문자열의 비교는 ==가 아닌 equals를 사용하자.\n3.5.1 논리 연산자   !\n논리연산자로 (AND), (OR) 연산자가 있다.\n논리 연산자는 이항 연산자로 피연산자는 모두 boolean 타입이어야 한다.\n논리연산자와 함께 많이 사용되는 연산자로 논리 부정 연산자 !\n논리 부정 연산자는 일항 연산자로 피연산자는 boolean 타입이어야 한다.\n피연산자 모두 true 일때만 true\n피연산자 중 하나만 true 여도 true\n피연산자의 값이 true이면 결과는 false, false이면 true\n,  를 사용해 논리 연산을 수행할 때 효율적인 연산을 하도록 하자.\n예를 들어  연산자 좌항과 우항에 각 기 계산식이 들어온 경우  연산자의 좌항이\n이면 우항은 계산식이 실행되지 않는다.\n이면 우항이 계산되지 않으므로 **연산량이 적은 계산을 좌항에 배치하자**\n3.5.2 비트 연산자     << >>\n비트연산자는 피연산자를 \"비트\" 단위로 논리 연산하다.\n피연산자로는 정수(문자 포함)만 사용할 수 있다.\n피연산자 양쪽 모두 1이어야 1이다.\n피연산자 중 한쪽이 1이면 1이다.\nXOR(Exclusive OR) 비트 연산자\n피연산자의 비트가 같지 않으면 1이다.\n피연산자의 비트를 반전 시킨다.\n0이면 1, 1이면 0\n비트의 자리를 왼쪽 혹은 오른쪽으로 이동 시킨다.\n범위를 벗어난 값은 버려지고, 빈자리는 0으로 채워진다.\n안드로이드에서  비트 연산자를 쓰는 경우가 종종있다.\n비트 연산의 특성 상 특정 비트의 값을 변경할 때 사용된다.\n비트연산자를 쓰는 이유가 빠르기 때문에 쓴다 이야기하는건 옳지 않다.\n4, *8, /2, /4, /8과 같은 산술 연산의 경우 컴파일러가 좌측 쉬프트, 우측 쉬프트 연산으로 대체하는 경우가 있어 속도적인 이점이 전혀 없을 수도 있다.\n오히려 \"가독성\"을 해칠 수 있기 때문에 빠르다는 이유로 쉬프트 연산을 고집하진 말자.\n3.6 그 외의 연산자\n3.6.1 조건 연산자 ?\n: (Ternary 3중' Conditional Operator)\n조건 연산자는 3항 연산자로, 조건연산자와 함께 조건식, 조건식이 참 일 때의 값, 조건식이 거짓일 때의 값을 사용한다.\n( x>y ) {\n3.6.2 대입 연산자 =\n대입 연산자는 2항 연산자로, 연산자 우측의 값을 좌측에 저장한다.\n대입 연산자의 좌측 피연산자를 l-value(left value), 우측의 피연산자를 r-value(right value)라 한다.\nr-value는 상수, 리터럴, 변수를 사용할 수 있는 반면, l-value는 우측 피연산자의 값이 저장되야 하므로 변경 가능한 변수만 사용할 수 있다.\n복합 대입 연산자 (Compound Assignment Operator)\n2항 연산자로, 좌항과 우항을 대입연산자 앞에 작성한 연산(산술연산, 비트연산)을 수행한 후 그 결과를 좌항에 대입한다.\n대입 연산자의 특성 상 좌항은 변수만 사용될 수 있다.\n// x = x+y\n// x = x-y\n// x = x*y\n// x = x/y\n// x = xy\n// x = x<\n// x = x>>y\n// x = x!y"
  },
  {
    "chapter": 3,
    "title": "4. 조건문과 반복문",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter4.html",
    "content": "제어문 : 프로그램의 흐름을 바꾸는 역할을 하는 문장들.\n제어문에는 조건문과 반복문이 있다.\n조건문은 프로그램의 조건에 따라 문장이 수행되도록 한다.\n가장 기본적인 조건문으로 조건식과 괄호로 구성된다.\nint a = 0\nif (a == 0){\n조건식은 일반적으로 비교연산자 및 논리연산자로 구성된다.\n아래에 샘플로 몇 가지를 살펴보자.\n90 <= x  x <= 100        : 정수 x가 90이상이고, 100 이하인 경우.\n정수 x의 값이 90100 인 경우 참.\n90 >= x  x >= 100        : 정수 x가 90이하거나, 100 이상인 경우.\n정수 x의 값이 9199인 경우 거짓.\nstr.equals(\"yes\")        : 문자열 str의 내용이 \"yes\"일 경우 참.\nstr.equalsIgnoreCase(\"yes\")        : 문자열 str의 내용이 \"yes\"일 경우 참.\n이러한 조건식 중 실수하기 쉬운 것이 등가비교 연산자 \"==\"를 \"=\"로 사용하는 것이며, \"==\"와 \"=\"가 틀린 이유는 \"=\"는 참/거짓\n이 될 수 없기 때문이다.\n변수 x 가 10인 경우, 참 또는 거짓으로 확인할 수 있다.\nif (x == 10){\n변수 x는 10, 참 또는 거짓으로 확인할 수 없다.\nif (x = 10){\n{}를 이용해서 여러 문장들을 하나의 단위로 묶어줄 수 있는데, 이것을 블럭이라고 한다.\n블럭은 '{'로 시작해서 '}'로 끝나며, 마지막에는 일반 문장에서 붙이는 ';'를 붙이지 않는다.\n만약 수행문장이 한 문장일 경우에는 블럭 없이 사용할 수 있지만, 혹시 나중에 수행문장이 추가되거나 조건문의 수행문장임을 표현하기 위해서라도\n블럭을 사용하는 것이 좋다.\nif (조건식) System.out.printf(\"테스트 입니다.\n\");    <- 조건문의 수행문장\n\");    <- 조건문과는 상관없는 문장.\nif-else문은 기본 if문에서 if의 조건식에 부합되지 않는 경우 else의 수행문장 또는 블럭 내 수행문장(들)을 수행한다.\n변수 x가 10인 경우 블럭 -1 문장을 수행하지만, 아닌 경우에는 -2 문장만 수행한다.\n변수 x가 10인 경우 블럭 -1 문장을 수행하지만, 변수 x가 10이 아닌 경우 즉 조건식이 참이 아닌 나머지 모든 경우에 -3 문장을 수행하고, 이 후 -2 순으로 문장을 수행한다.\n만약 조건문으로 처리해야할 조건이 하나(if문), 둘(if-else문)이 아닌 셋 이상이라면 if-else if문을 사용한다.\n기본 구조는 아래와 같이 if, else if, else 로 구성되며, else는 생략 가능하다.\n다만 else를 생략할 경우 if, else if 조건식에 부합되지 않는 경우에는 수행되는 문장이 없다.\n} else if (조건식 2){\n} else if (조건식 3){\nif문 블럭내에 다른 if문을 포함시키는 것.\nif문의 경우 조건식을 통해 참/거짓 이라는 두 가지 결과밖에 처리할 수 없기 때문에, 다양한 경우의 수를 처리하기 위해서 switch문을 사용한다.\nswitch (x >= 10) {\nSystem.out.printf(\"x는 13 이상 입니다.\nswitch문의 조건식 결과는 정수 또는 문자열이어야 한다.\ncase문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.\nSystem.out.printf(\"x는 문자열 상수 입니다.\ncase yes :                            <- 문자열 상수로 에러 발생\n보통 switch문은 if문으로 변환이 가능하지만, 반대의 경우에는 변환이 되지 않는 경우가 많다.\n(switch문을 if문으로 변환하는 샘플)\nif (x == 10) {\n} else if (x == 11) {\n} else if (x == 12) {\nif문과 마찬가지로 switch문도 중첩이 가능하다.\nSystem.out.printf(\"2000년 이 전 출생자 입니다.\nSystem.out.printf(\"2000년 이 후 출생자 입니다.\n반복문 - for, while, do-while\n\"I can do it.\"\n// 조건식이 true 일때 코드 실행\n두개의 변수 사용 (comma 사용)\nc. 초기화, 조건식 증감식 생략\n조건식이 항상 true로 간주되어 무한반복되므로 {} 블럭안에 if를 넣어 특정조건이면 빠져나오도록 해야한다.\n\"d x d = dn\"\n, i, j, i*j);\n{} 블럭안에 코드가 한줄이면 {} 생략가능\n결과적으로는 아래와 같이 사용가능\ne. 향상된 for문(enhanced for statement)\n( 타입 변수명 : 배열 또는 컬렉션 {\n예를 들어 배열을 iterate 할 경우 기존의 for문과 enhanced된 for문을 비교하면 다음과 같다.\n[] arr = {\n; i< arr.length; i++){\n// 조건식이 true일경우 실행할 코드\n\"자, 이제 카운트 다운을 시작합니다.\"\n자, 이제 카운트 다운을 시작합니다.\n여기서 아래 코드를 보면\n아무것도 하지 않고 2,000,000,000 돌때까지 println의 실행을 늦추는것\n블럭내 문장이 한줄이므로 {} 생략하면 다음과 같이 표기 가능\n그런데 다음과 같이 작성한 경우, 어떤 output이 예상되는가?\n** 빈문장을 ';' 10번 반복한 후 \"i=11\" 츨력\nwhile문의 변형으로 조건식이 {}을 먼저 수행한 후에 평가된다 while문은 {} 내에 코드가 한번도 실행되지 않을 경우가 있으나, do-while문의 경우는 최소 한번은 실행된다.\n많이 쓰이지는 않으나, 다음 [예제 1]과 같이 반복적인 입력을 받아 처리를 해야 할 경우 유용하다.\n// 먼저 코드 실행 후 조건식 검토\n\"1과 100사이의 정수를 입력하세요>.\"\nString tmp = scanner.nextLine();\n\"더 작은 수로 다시 시도해보세요.\"\n\"더 큰 수로 다시 시도해보세요.\"\n반복문에서의 break는 자신이 포함된 가장 가까운 반복문을 벗어나는데 쓰인다.\n아래 예제는 이전 for문에서 보았던 for(;;) {} 형태의 반복문인데 이경우 조건문과 break가 반드시 같이 사용되어야 한다.\n// -->while {}내의 코드 실행하지 않고 while 문을 완젼히 벗어난다.\ncontinue 문은 반복문내에서 {} 내의 continue 이후 코드를 실행하지 않고 다음 반복을 계속 수행할때 쓰이며, 보통 if 문과 함께 특정 조건을 만족하는 경우 다음 반복으로 넘어가서 진행하도록 한다\n[예제 1 Output] 3의 배수만 제외하고 프린트\n2.5 이름 붙은 반복문\nbreak 문은 근접한 하나의 반복문만 벗어날 수 있기 때문에 여러개의 반복문이 중첩된 경유 break문으로 중첩 반복문을 완전히 벗어날 수 없다.\n이때, 중첩 반복문 앞에 이름을 붙이고, break문과 continue문에 이름을 지정해 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있게 한다."
  },
  {
    "chapter": 4,
    "title": "5. 배열",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter5.html",
    "content": "같은 타입의 여러 변수를 하나의 묶음으로 다루는 것\n많은 양의 데이터를 손쉽게 다룰 수 있다.\n데이터의 수가 아무리 많아도 배열의 길이만 바꾸면 된다.\n: 서로 다른 타입의 변수들로 구성된 배열은 만들 수 없다.\n서로 다른 타입의 값들을 하나로 묶으려면 '클래스'를 정의하면 되는데, 클래스는 다음장에서\n: 배열은 각 배열요소의 저장공간이 연속적으로 배치되어 있다.\n1.2 배열의 선언과 생성\n원하는 타입의 변수를 선언하고 변수 또는 타입에 배열임을 의미하는 대괄호 []를 붙인다.\n: 저자는 타입에 대괄호를 붙이는 것을 선호 (대괄호가 타입의 일부라고 보기때문)\n배열을 선언하는 것은 단지 생성된 배열을 다루기 위한 참조변수를 위한 공간이 만들어질 뿐이고, 배열을 생성해야만 비로소 값을 저장할 수 있는 공간이 만들어진다.\n연산자 new와 함께 배열의 타입과 길이 지정\n// int 형 배열 참조변수 score를 선언 (아직 데이터를 저장할 공간은 마련되지 않음)\n// 연산자 new에 의해 메모리 빈 공간에 5개의 int형 데이터를 저장할 수 있는 공간 마련\n// 배열의 각 요소는 자동으로 int형의 기본값인 0으로 초기화 됨\n// 대입연산자 =에 의해 배열의 주소가 int형 배열 참조변수 score에 저장됨\n// 길이가 5인 int 배열, 배열 score\n// 이제 참조변수 score를 통해서 배열에 값을 저장하거나 읽어 올 수 있다.\n배열의 선언과 생성을 동시에\n// 배열 선언과 생성을 동시에\n1.3 배열의 길이와 인덱스\n생성된 배열의 각 저장공간\n// 배열 요소 접근방식\n배열의 요소마다 붙여진 일련번호.\n인덱스는 상수, 변수, 수식 모두 가능\n: index의 범위를 벗어난 값을 사용하면 오류 발생 (IndexOutOfBoundsException)\n// 길이가 5인 int 배열.\nindex 범위 = 04\n// index로 상수를 쓸수 있음.\n배열 score의 4번째 요소에 100을 저장\n// 배열 요소 접근.\n배열 score의 4번째 요소에 저장된 값을 읽어서 value에 저장\n// index로 변수도 쓸 수 있음\n// index로 수식도 쓸 수 있음 (수식이 먼저 계산되어 index를 결정)\n// index의 범위를 벗어남 -> IndexOutOfBoundsException\n배열의 요소 개수, 즉 값을 저장할 수 있는 공간의 개수\n(당연히) 양의 정수(0포함)이어야 하며, 최대값은 int 타입의 최대값 (약 20억)\n길이가 0인 배열도 생성 가능\n// 길이가 5인 int 배열\n// tmp = 5\n// 에러 (배열의 길이는 변경 불가)\n: for문 조건식에 배열의 길이를 직접 적어주는 것보다 '배열이름.length'를 사용하는 것이 안전하다.\n코딩하다가 중간에 배열 길이 변경시 일일이 찾아서 고쳐주지 않아도 되기 때문이다.\n배열 길이 변경 방법\n더 큰 배열을 새로 생성\n기존 배열의 내용을 새로운 배열에 복사\n: 이 작업은 비용이 많이 들므로 처음부터 넉넉하게 잡아 주는 것이 좋다.\n너무 크게 잡으면 메모리 낭비이므로 기존의 2배정도 길이로 생성하는 것이 좋다.\n배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화 된다.\n원하는 값으로 초기화 하려면 각 요소마다 값을 지정해야한다.\n// name[0] -> null\n// name[1] -> null\n// name[2] -> null\n참조형 변수의 초기값은 null 이다.\n2.2 String 배열의 초기화\n배열의 각 요소에 문자열을 지정하자.\n괄호{} 를 사용하여 간단히 초기화하자.\n참조형 배열(객체 배열)의 메모리에 대한 이해\n// name    -> 0x100\n// name[0] -> 0x200 -> \"Kim\"\n// name[1] -> 0x300 -> \"Park\"\n// name[2] -> 0x400 -> \"Yi\"\n; i < names.length; i++) {\nString tmp = names[\n// 배열의 names 의 세번째 요소를 tmp 에 저장\n(String str : names)\n// 향상된 for 문\n[] hex = {\nString[] binary = {\n; i < hex.length; i++) {\nresult += binary[hex[i] -\n// '8' - '0'의 결과는 8이다.\n// 'C' - 'A'의 결과는 2\n2.3 char 배열과 String 클래스\nString 클래스는 char 배열에 기능을 추가한 것이다.\n데이터 : char 배열\n기능 :  length (문자열의 길이), substring (일부 문자열), equals (문자열 내용 비교)\n부록 : Char[] vs String\n// str1       : java.study\n// charArray1 : [C\n// str1       : 966802fd\n// str2       : 966802fd\n; i < src.length(); i++) {\n// src 의 i 번째 문자를 ch 에 저장\n[] chArr = src.toCharArray();\n// String 을 char[] 로 변환\n// char 배열(char[])을 출력\nString[] morse = {\n; i < source.length(); i++) {\nresult += morse[source.charAt(i) -\n2.4 커맨드 라인을 통해 입력받기\n; i < args.length; i++) {\n// java ArrayEx16 abc 123 \"Hello World\"\n// args[0] = \"abc\"\n// args[1] = \"123\"\n// args[2] = \"Hello World\"\n\"usage: java Array17 NUM1 OP NUM2\"\nresult = num1 + num2;\nresult = num1 - num2;\nresult = num1 * num2;\nresult = num1 / num2;\n// usage: java Array17 NUM1 OP NUM2\n// java ArrayEx17 10 + 3\n// java ArrayEx17 10 x 3\n3.1 2차원 배열의 선언과 인덱스\n4행 3열의 2차원 배열 생성하기\n3.2 2차원 배열의 초기화\n생성과 초기화를 함께 하기\n[][] arr = {\n// arr       -> 0x100\n// arr[0]    -> 0x200\n// arr[0][0] -> 1\n// arr[0][1] -> 2\n// arr[0][2] -> 3\n// arr[1]    -> 0x300\n// arr[1][0] -> 4\n// arr[1][1] -> 5\n// arr[1][2] -> 6\n[][] score = {\n; i < score.length; i++) {\n; j < score[i].length; j++) {\n, i, j, score[i][j]);\n[] tmp : score) {\ni : tmp) {\n\"번호 국어 영어 수학 총점 평균\"\navg = sum / (\n, korTotal, engTotal, mathTotal);\n// 번호 국어 영어 수학 총점 평균\n// 1  100  100  100  300 100.0\n// 2   20   20   20   60  20.0\n// 3   30   30   30   90  30.0\n// 4   40   40   40  120  40.0\n// 5   50   50   50  150  50.0\n// 총점:240  240  240\n; i < score.length; i++)\n; j < score[i].length; j++)\n2차원 배열 -> 배열의 배열\n//  5 x 3\n// 5 x n\n// 생성과 초기화를 동시에\n3.4 다차원 배열의 활용"
  },
  {
    "chapter": 5,
    "title": "6. 객체지향 프로그래밍 I",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter6.html",
    "content": "실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 객체지향이론을 탄생시킴\n객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다'\n1960년대 시뮬라라는 최초의 객체지향언어가 탄생하였으나 절차적 언어에 밀려 비주류로 있었으나 1995년 자바가 발표되고\n1990년대 말에 인터넷 발전과 함께 객체지향언어가 프로그래밍언어의 주류로 자리 잡음.\n1 코드의 재사용성이 높다.\n새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.\n2 코드의 관리가 용이하다.\n코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.\n3 신괴성이 높은 프로그래밍을 가능하게 한다.\n제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,\n코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.\n너무 객체지향개념에 얽매여서 고민하기 보다는 일단 프로그램을 완성하고 어떻게 하면 보다 객체지향적으로\n코드를 개선할 수 있을지를 고민하는게 좋다\n클래스와 객체의 정의와 용도\n클래스의 정의 - 클래스란 객체를 정의해 놓은 것이다.\n클래스의 용도 - 클래스는 객체를 생성하는데 사용된다.\n객체의 정의 - 실제로 존재하는 것.\n객체의 용도 - 객체가 가지고 있는 기능과 속성에 따라 다름\n클래스와 객체의 관계는 제품설계도와 이를 이용해 만든 제품과의 관계라고 할 수 있다.\nJDK(Java Development kit)에서는 많은수의 클래스를 기본적으로 제공하고 있으며, 우리는 이 클래스들을 이용해서\n원하는 기능의 프로그램을 보다 쉽게 작성할 수 있다.\n어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스 라고 한다.\n객체가 좀더 포괄적인 의미를 갖고 있으나 '책상은 책상 클래스의 인스턴스다.\n'와 같은 어떤 클래스로부터 만들어진 것인지를 강조할때는\n객체보다는 인스턴스가 어울리며 이와같이 문맥에따라 구별하여 사용하는 것이 좋다.\n클래스 -> 인스턴스화 -> 인스턴스(객체)\n객체의 구성요소 - 속성과 기능\n객체는 속성과 기능을 가지고 있으며 이를 그 객체의 맴버라 한다.\n클래스랑 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어있다.\n속성과 기능은 같은 뜻의 여러가지 용어가 있으나 객체지향 프로그래밍에서는 속성과 기능을 각각 변수와 메서드로 표한한다.\n속성(property) - 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)\n기능(function) - 메서드(method), 함수(function), 행위(behavior)\nTv클래스를 선언한 것은 Tv설계도를 작성한 것에 불과하므로 Tv인스턴스를 생성해야 사용할 수 있는데\n클래스로부터 인스턴스를 생성하는 방법은 여러가지가 있다.\n// 클래스의 객체를 참조하기 위한 참조변수를 선언\n// 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장\n// Tv클래스 타입의 참조변수 t를 선언\n// Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장\n{ power = !power; }\n// TV를 켜거나 끄는 기능을 하는 메서드\n// TV의 채널을 높이는 기능을 하는 매서드\n// TV의 채널을 낮추는 기능을 하는 매서드\n메모리에 참조변수 t를 위한 공간이 마련된다.\nt = new Tv();\n연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성되며 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다.\n그 다음에는 대입연산자(=)에 의해서 생성된 객체의 주소값이 참조변수 T에 저장되며 이 참조변수를 통해서 인스턴스를 다룰 수 있다.\n인스턴스의 멤버변수 channel에 7을 저장.\n인스턴스의 멤버변수를 사용하려면 '참조변수.멤버번수'와 같이 하면 된다.\nt가 참조하고있는 Tv인스턴스의 channelDown메서드를 호출한다.\nSystem.out.println(\"현재 채널은 \" + t.channel + \"입니다.\n참조변수 t가 참조하고 있는 Tv인스턴스의 멤버변수 channel에 저장되어 있는 값을 출력한다.\n인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.\n// channel값을 7으로 한다.\n\"t1의 channel값을 7로 변경하였습니다.\"\nt1의 channel값을 7로 변경하였습니다.\n같은 클래스로부터 생성되었을지라도 각 인스턴스의 속성은 서로 다른 값을 유지할 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.\n// t1이 저장하고 있는 값(주소)를 t2에 저장한다.\nt1이 가지고 있던 인스턴스의 주소를 t2에 저장하게 되어 t2역시 t1과 같은 인스턴스를 참조하게 되어 참은 channel값을 출력한다.\n참조변수에는 하나의 값만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 참조하는 것은 가능하지만\n하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능하지 않다.\n많은 수의 객체를 다뤄야 할때 배열로 다루면 편리하며 이를 '객체 배열'이라고 한다.\n그렇다고 객체 배열 안에 객체가 저장되는 것은 아니고, 객체의 주소가 저장된다.\nTv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열\n객체를 다루기 위한 참조변수들이 만들어진 것일 뿐, 아직 객체가 저장되지 않았으며 객체를 생성해서 객체 배열의 각 요소에\n저장하는 것을 잊으면 안 된다.\n// 참조변수 배열(객체 배열)을 생성\n// 겍체를 생성해서 배열의 각 요소에 저장\nTv[] tvArr = {\n명시적 초기화 -> 클래스 초기화 블럭\n인스턴스변수 - 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자"
  },
  {
    "chapter": 6,
    "title": "7. 객체지향 프로그래밍 II",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter7.html",
    "content": "상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것.\n적은 양의 코드로 새로운 클래스를 작성할 수 있다.\n코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이하다\nclass Child extends Parent {\nChild 클래스는 Parent 클래스의 모든 멤버를 상속 받기 때문에 Child 클래스는 Parent 클래스를 포함한다고 할 수 있다.\n그러나 Child 클래스에 변수를 추가해도 Parent 클래스는 아무런 영향을 받지 않는다.\n멤버변수 => int a\n멤버변수 => int a, b\n생성자와 초기화 블럭은 상속되지 않으며 멤버만 상속된다.\nChild 클래스의 멤버 개수는 Parent 클래스보다 같거나 많다.\n하나의 Parent 클래스를 여러개의 Child 클래스가 상속 받았을 때 각각의 Child 클래스 간에는 아무런 관계도 성립되지 않는다.\n=> Parent 클래스만 같기 때문에, Parent 클래스의 멤버(변수 메소드)는 동일하게 상속받아 사용하지만 Child 클래스에서 추가한 멤버에 대해서는 사용할 수 없으므로..\n따라서 Child 클래스들에 공통적으로 사용될 멤버가 있다면 Parent 클래스에 생성하는 것이 좋다.\n상속 관계를 이용하는 이유 중 하나는 다음과 같다.\n같은 내용의 코드를 한 곳에서 관리함으로써 코드의 중복이 줄어든다.\n=> 코드의 중복이 많아지면 유지보수가 어렵고 일관성을 유지하기 어렵다.\nParent 클래스를 따로 인스턴스를 생성하지 않아도 Child 클래스의 인스턴스를 생성하면 Parent 클래스의 멤버도 함께 생성되기 때문에 Parent 클래스의 멤버들을 사용할 수 있다.\n클래스간의 포함관계 (클래스간의 관계 - 포함관계)\n상속 이외에도 클래스를 재사용하는 다른 방법은 포함 관계를 맺어 주는 것이다.\nPoint p = new Point();\n상속으로 클래스를 작성하거나 포함 관계를 맺어 주는데 있어 애매한 경우가 있는데 이럴 경우 아래와 같이 확인한다.\n상속 관계 : 은 이다.\n포함 관계 : 은 을 가지고 있다.\n원은 점을 가지고 있다.\n자바에서는 단일 상속만 허용한다.\nclass TVCR extends TV, VCR {\n단일 상속이 하나의 Parent 클래스만 상속받을 수 있기 때문에 다중 상속에 비해 불편한 점도 있겠지만 클래스 간 관계가 더 명확해지고 코드를 더욱 신뢰할 수 있게\n만들어 준다는 점에서 다중상속에 비해 유리하다.\n(인터페이스로 비슷하게 구현 가능, 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.)\nObject 클래스 - 모든 클래스의 조상\nObject 클래스는 모든 클래스 상속계층도의 최상위에 있는 Parent 클래스이다.\n어떤 클래스에서 다른 클래스를 상속 받지 않는 경우 컴파일러는 자동적으로 extends Object를 추가하여 Object 클래스를 상속받도록 한다.\nclass Test (extends Object) {\n그동안 toString()이나 qeuals(Object o)와 같은 메소드를 별도로 정의하지 않고도 사용할 수 있었던 이유는 이 메소드들이 Object 클래스에 정의된 것들이기 때문이다.\nParent 클래스로부터 상속받은 메소드의 내용을 변경하는 것을 오버라이딩이라고 한다.\nreturn \"x :\" + x + \", y :\" + y;\nclass Point3D extends Point {\nreturn \"x :\" + x + \", y :\" + y  + \", z :\" + z;\n오버라이딩은 상속받은 메소드의 내용만 새로 작성하는 것이므로 선언부는 Parent 클래스의 것과 완전히 일치해야 한다.\nParent 클래스의 메소드 및 Child 클래스의 메소드는\n요약하자면 선언부가 서로 일치해야 한다는 것이지만 접근 제어자와 예외는 아래의 제한된 조건 하에서 변경할 수 있다.\n접근 제어자는 Parent 클래스의 메소드보다 좁은 범위로 변경할 수 없다.\n접근 제어자 : public, protected, default, private\n(그 외 제어자 : static, final, abstract, native, transient, synchronized, volatle, strictfp)\nParent 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.\nvoid testMethod() throws IOException, SQLException {\nvoid testMethod() throws IOException { (o)\nvoid testMethod() throws Exception { (x)\n인스턴스 메소드를 static 메소드로 또는 그 반대로 변경할 수 없다.\n오버로딩 : 기존에 없는 새로운(new) 메소드를 정의하는 것\n오버라이딩 : 상속받은 메소드의 내용을 변경하는 것(modify)\nvoid parentTest() {}        - 오버라이딩\nvoid parentTest(int a) {}   - 오버로딩, 상속받은 메소드와 달리 매개변수 int a 추가\nchild 클래스에서 parent 클래스의 상속받은 멤버를 참조하는데 사용되는 참조변수.\n덧 상속받은 parent 클래스의 변수도 child 클래스의 변수이므로 this를 사용할 수 있지만 상속받은 변수와 같은 child 변수가 있을 경우 구별을 위해 사용.\n다만 static 메소드에서는 사용할 수 없다.\nsuper() - 조상(부모) 클래스의 생성자\nsuper()는 생성자이며 this()는 같은 클래스 내 다른 생성자를 호출할 때 사용되지만 super()는 Parent 클래스의 생성자를 홏루할 때 사용된다.\nObject 클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자 this()또는 super()를 호출해야 한다.\n그렇지 않을 경우 컴파일러가 자동적으로 super();를 삽입한다.\nParent 클래스를 상속받으면 Parent 클래스의 멤버를 상속받아 사용할 수 있지만 멤버변수를 사용하기 전 Parent 클래스의 멤버변수를 Parent 클래스의 생성자로 초기화한다.\n패키지란 클래스의 묶음으로 클래스 또는 인터페이스를 포함시킬 수 있으며 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로서 효율적으로 관리할 수 있다.\n같은 이름의 클래스라도 서로 다른 패키지에 있는 경우 존재하는 것이 가능하며, 클래스의 실제 이름은 패키지명을 포함한다.\n클래스가 물리적으로 하나의 클래스파일(.class) 인 것처럼 패키지는 물리적으로 하나의 디렉토리이다.\n따라서 패키지에 속한 클래스는 해당 패키지 디렉토리에 존재하는 클래스 파일이어야 한다.\n하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.\n모든 클래스는 반드시 하나의 패키지에 속해야 한다.\n)을 구분자로 하여 계층구조로 구성할 수 있다.\n패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.\n패키지 선언문은 반드시 소스파일에서 주석과 공백을 제외한 첫 번째 문장이어야 하며 단 한번만 선언될 수 있다.\n선언된 클래스나 인터페이스는 선언된 패키지에 속하게 된다.\n패키지명은 대소문자를 모두 허용하지만 클래스명과의 구분을 위해 소문자로 한다.\n패키지를 선언하지 않으면 기본적으로 제공하는 이름없는 패키지(unnamed package) 떄문이다.\n소스코드 작성 시 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다.\n코드 작성 전 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시하여 소스코드에서는 사용되는 클래스 이름만을 사용할 수 있다.\nimport문은 package문 다음에 클래스 선언문 이전에 위치해야 한다.\nimport문은 한 소스파일에 여러 번 선언할 수 있다.\n클래스 이름 지정 대신 '\n' 사용 시 지정된 패키지에 속하는 모든 클래스를 import하여 패키지명 없이 사용할 수 있다.\n(클래스명을 지정하는 것과 '\n'을 사용하는 것은 실행 시 성능상의 차이는 전혀 없다고 함...)\n'*'을 쓸 경우 하위 패키지의 클래스까지 포함하는 것은 아니므로 주의한다.\n같은 패키지 내의 클래스들은 import 하지 않아도 패키지명을 생략할 수 있다.\nimport문과 마찬가지로 static import문을 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.\n제어자는 클래스 변수 또는 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여하며 접근 제어자 및 그 외의 제어자로 나눌 수 있다.\n그 외 제어자 : static, final, abstract, native, transient, synchronized, volatile, strictfp\n클래스나 멤버변수와 메소드에 주로 사용되며 하나의 대상에 대해 여러 제어자를 조합하여 사용하는 것이 가능하다\n접근 제어자는 한 번에 네 가지 중 하나만 사용할 수 있다.\n제어자간 순서는 관계 없지만 주로 접근 제어자를 제일 왼쪽에 놓는다.\nstatic - 클래스의, 공통적인\n'클래스의 또는 '공통적인' 의미.\n멤버변수 메소드 초기화 블럭 등에 사용된다.\n인스턴스 멤버를 사용하지 않는 메소드는 static을 붙여서 static 메소드로 선언하는 것을 고려해 보도록 하자.\n(인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠르다.)\nfinal - 마지막의, 변경될 수 없는\n'마지막의' 또는 '변경될 수 없는' 의미.\n변수에 사용되면 값을 변경할 수 없는 상수가 된다.\n메소드에 사용되면 오버라이딩을 할 수 없다.\n클래스에 사용되면 다른 클래스에서 상속할 수 없다.\n클래스 메소드 멤버변수 지역변수 등에 사용된다.\nfinal이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.\nabstract - 추상의, 미완성의\n메소드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메소드를 선언하는 사용.\n클래스 및 메소드 등에 사용된다.\n추상 클래스는 아직 완성되지 않은 메소드가 존재하므로 인스턴스를 생성할 수 없다.\n멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.\n접근 제어자가 지정되어 있지 않다면 접근 제어자는 default.\n접근 제어자의 범위 나열\npublic > protected > default > private\npublic은 접근 제한이 전혀 없다.\nprotected는 패키지에 관계 없이 상속관계에 있는 Child 클래스 내로만 제한한다.\ndefault는 같은 패키지내 클래스 내로만 제한한다.\nprivate은 같은 클래스 내로만 제한한다.\n접근 제어자를 사용하는 이유\n접근 제어자는 클래스 내부에 선언된 데이터를 보호하기 위해서 사용한다.\n외부에는 불필요한 내부적으로 사용되는 부분을 감추기 위해\n제어자를 조합할 때 주의점\n메소드에 static과 abstract를 함께 사용할 수 없다.\n클래스에 abstract과 final을 동시에 사용할 수 없다.\n3. abstract메소드의 접근 제어자가 private일 수 없다.\n메소드에 private과 final을 같이 사용할 필요는 없다.\n(클래스에서는 상속할 수 없는 클래스임을 알리기 위해 사용하는 것을 추천)\n여러가지 형태를 가질 수 있는 능력\"\n을 통해 발생하며, 부모클래스 타입의 참조 변수로 자식클래스의 인스턴스를 참조할 수 있는것을 다형성이라 한다.\n기본형 변수와 마찬가지로 참조타입의 변수도 형변환이 가능함.\n상속관계에 있는 클래스간의 형변환만 가능\n형제 관게의 형변환은 불가\n// 캐스팅 연산자 생략 가능\nPhone castedPhone1 = iphone;\nPhone castedPhone2 = androidPhone;\n// 캐스팅 연산자 생략 불가\n// Runtime Error : ClassCaseException\niPhone castedPhone3 = (iPhone)phone;\nAndroidPhone castedPhone4 = (AndroidPhone)phone;\niPhone castedPhone5 = (iPhone)androidPhone;\nAndroidPhone castedPhone6 = (AndroidPhone)iphone;\n참조 변수가 참조하고 있는 인스턴스의 타입을 알아보기 위해 사용\n주로 조건문과 함께 사용되며, instanceof 연산자 우항에 타입 확인을 위한 클래스명 등을 지정\n역시 instanceof 연산자에 의해 구분 가능\ninstanceof는 그럼 왜 쓸까?\n바로 Down-Casting을 통해 형변환에 의해\n를 통해 직접 비교하는 방법도 있음\n부모클래스와 자식클래스에 같은 이름의 멤버변수와 메소드가 있으면?\n상속 관계에서 부모와 자식에 중복된 이름을 사용하지 말자\n매개변수의 다형성  여러 종류의 객체를 배열로 다루기\n다형성을 매개변수의 인자로 사용할 수 있음\n다형성을 통해 배열로 다룰 수 있음\n다형성을 통한 로직의 구현은 자바세계에서 빈번한 일\n(미완성 설계도란 표현은 적절치 못한 것 같음)\n미완성 메서드를 포함하고 있음\n미완성 설계도를 통해 제품을 만들 수 없듯이 인스턴스 생성 불가\n클래스의 완성을 자식클래스에 위임\n메서드의 구현부가 없는 것이 추상메서드\n메서드의 구현을 자식 클래스에게 위임\n메서드 선언 시 abstract 키워드를 앞에 붙여주고, 메서드의 본문인 {} 생략하고 세미콜론으로 마무리\n// 추상클래스를 상속받아 추상메서드 구현\n// 추상클래스를 상속받았지만, 추상메서드를 구현하지 않아 추상클래스로 선언\n추상화 : 클래스간의 공통점을 찾아 공통의 조상을 만드는 작업\n구체화 : 상속을 통해 클래스를 구현/확장하는 작업\n그런데 추상메서드나 추상클래스를 사용하지 않고 구현하면 어떻게 될까?\n추상메서드나 추상클래스를 사용하지 않고 구현하는것은 사실 큰 차이가 없다\n개인적으로 추상클래스 대신 인터페이스를 선호\n를 가질 수 없다\ninterface 키워드와 함께 인터페이스 이름 지정\n멤버변수는 선언할 수 없지만, static final 상수는 선언할 수 있다\n메서드 선언 시 public, abstract는 생략 가능\n타입 상수이름 = 리터럴;\n클래스 상속과 마찬가지로 extends 키워드를 통해 인터페이스간의 상속도 가능\n클래스에 implements 키워드를 통해 인터페이스 구현을 위임할 수 있다\n인터페이스 구현은 추상메서드를 구현할 때와 동일한 룰이 적용됨\n클래스 상속 시 extends 키워드를 사용해 상속받을 클래스를 지정.\n이때 하나의 클래스만 지정이 가능\n인터페이스는 상속(위임) 시 implements 키워드를 사용해 구현을 위임받을 인터페이스 지정.\n여러 인터페이스 지정 가능\n인터페이스 역시 클래스 상속 시 생기는 다형성과 동일한 룰을 따름\n클래스 상속을 통한 다형성\n은 어떤 차이가 날까?\n개발 시간을 단축 시킬 수 있다\n인터페이스를 통해 프로토콜만 맞추고, 따로 작업할 수 있다\n인터페이스를 잘 만들면 표준화가 가능\n서로 관계없는 클래스들에게 관계를 맺어줄 수 있다\n관계를 잘 맺어줄 수 있다\n클래스의 상속을 통한 구현보다 클래스 간의 의존성을 낮춘다.\n인터페이스의 장점 중 클래스 간의 의존성이 어떻게 낮아지는지에 대한 이야기\n디폴트 메서드와 static 메서드\n디폴트 메서드와 static 메서드를 인터페이스에서 사용 가능(JDK 1.8)\n인터페이스는 변경 시 인터페이스에 대한 구현이 위임된 모든 클래스에 영향을 준다.\n디폴트 메서드는 이러한 문제를 해결해줌.\n그런데 남용하면 인터페이스의 장점이 사라진다.\n디폴트 메서드는 클래스에서 오버라이딩 가능\n클래스의 선언이 클래스 내부에 선언된 경우\n새롭게 추가할 클래스가 특정 클래스 내부에서 사용되는 경우\n새롭게 추가할 클래스가 특정 Scope에 자주/쉽게 접근할 필요가 있는 경우\n새롭게 추가한 클래스와 특정 클래스가 같은 듯 같지 않은 경우\n내부 클래스의 종류와 특징\n내부 클래스에는 4가지 종류가 있음\n인스턴스 클래스 : 멤버변수 선언 위치에 클래스가 선언된 경우\n스태틱 클래스 : 멤버변수 선언 위치에 static과 함께 선언된 경우\n지역 클래스 : 메서드나 초기화 블럭에 선언되며, 선언된 영역 내부에서만 사용 가능\n익명 클래스 : 클래스의 선언과 객체의 생성을 통시에 하는 이름없는 클래스\n// 인스턴스 클래스 vs 스태틱 클래스\nOuterClass.InstanceClass instanceClass = outerClass.new InstanceClass();\n내부 클래스의 제어자와 접근성\n내부 클래스의 제어자는 외부 클래스의 접근 제어자의 영향을\n과 같은 제어자도 사용할 수 있으며,\n등도 함께 사용할 수 있다\n이름이 없는 클래스로 일회용 클래스\n이름이 없기 때문에 인스턴스 생성을 위해 상위 클래스의 이름이나 구현할 인터페이스의 이름을 사용해 생성자 호출\n이벤트 핸들링 작업에서 자주 사용된다"
  },
  {
    "chapter": 7,
    "title": "8. 예외처리 (Exception Handling)",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter8.html",
    "content": "프로그램 실행 중 어떤 원인에 의해 오작동하거나 비정상적으로 종료되는 경우가 있는데 이런 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다.\n발생시점에 따라 다음과 같이 두종류로 구분한다.\n컴파일 에러 (compile error) : 컴파일 시에 발생하는 에러\n런타임 에러 (runtime error) : 실행 시에 발생하는 에러\n논리적 에러 (logical error) : 실행은 되지만 의도와 다르게 동작하는 것\n자바에서는 실행 시에(run time) 발생하는 프로그램 오류를 다음과 같이 구분한다\n에러(error): i.e OutOfMemoryError, StackOverflowError)와 같이 수습될 수 없는 심각한 오류\n예외(exception): 코드에 의해 수습될 수 있는 다소 미약한 오류\n1.2 예외 클래스의 계층구조\nIOException RuntimeEx..  ..  OutOfMemoryError\n자바에서는 실행할 수 있는 오류를 각각 Exception, Error 클래스로 정의하였고 Object 클래스의 자손들(children)이다.\n또 모든 예외의 최고 조상은 Exception class이고 다음과 같이 표현할 수 있다.\n여기서 RuntimeException과 그 자손클래스들은 RuntimeException 클래스들이라하고 나머지들은 Exception 클래스라고 한다.\nRuntimeException classes: 프로그래밍 요소들과 관계가 깊다.\n0으로 나누려고 하는 경우에 발생하는 ArithmeticException, 값이 null인 참조변수의 멤버를 호출하려다가 생기는 NullPointerException 등등..\nException classes: 외부적인 영향으로 발생할 수 있는 예외.\n존재하지 않는 파일이름을 입력했거나(FileNotFoundException), 클래스의 이름을 잘못 적었거나 (ClassNotFoundException), 데이터 형식이 잘못된 경우 (DataFormatException)\n1.3 예외처리하기 - try-catch문\n정의 - 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것\n목적 - 프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지하는 것\nif else와 달리 try-catch는 블럭내에 포함된 문장이 하나여도 {} 를 생략할 수 없다.\ntry 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 여러개의 catch블럭을 사용할 수 있다.\ncatch 내에 또 다른 try-catch 블럭을 사용할 수 있는데 이때는 다음과 같이 변수 e를 중복해서 사용할 수 없다.\n// --> error 'e' 가 중복 선언\nresult = number / (\n<-- ArithmeticException이 발생했지만 프로그램은 종료하지 않고 대신\ntry-catch문에서 예외가 발생한 경우와 발생하지 않았을 때의 흐름을 다음과 같이 정리 할 수 있다.\ntry 블럭 내에서 예외가 발생한 경우\n발생한 예외와 일치하는 catch 블락이 있는지 확인한다.\n일치하는 catch 블럭을 찾게 되면 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다 만일 일치하는 catch블럭을 찾지 못하면 예외는 처리되지 못한다.\ntry 블럭내에서 예외가 발생하지 않은 경우\ncatch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.\n1.5 예외의 발생과 catch블럭\ncatch블럭은 괄호()와 블럭 {} 두 부분으로 나눠져 있는데 괄호 ()내에는 처리하고자 하는 예외와 같은 타입의 참조변수 하나를 선언해야 한다.\n예외가 발생하면 해당 클래스의 인스턴스가 만들어진다.\n예외가 발생한 문장이 try-catch문의 try블럭에 있다면, 이 예외를 처리할 수 있는 catch블럭을 찾게된다.\n첫번째 catch 블럭부터 차례로 내려가면서 catch블럭의 괄호()내에 선언된 참조변수의 종류와 생성된 예외클래스의 instance에 instanceof를 히용해 검사하고 결과가 true이면 예외처리한다.\n모든 예외 클래스는 Exception클래스의 자손이므로 Exception클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생해도 이 catch블럭에 의해 처리된다.\n예외가 발생했을 때 생성되는 예외클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있으며 다음 method들을 통해 정보를 얻을 수 있다.\nprintStackTrace(): 예외발생 당시의 호출스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력\ngetMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.\nat ExceptionEx8.main ( ExceptionEx8.java: 7)\n예외메세지 : /by zero\n멀티 catch블럭 : JDK 1.7부터 여러 catch블럭을  기호를 이훃애서 하나의 catch블럭으로 합칠 수 있게 되었으며 이를 멀티 catch블럭dlfk gksek.\n// from JDK 1.7\n멀티 블럭 사용할 때에  로 연결된 예외 클래스가 조상과 자손의 관계이면 에러가 생기므로 (불필요한 코드를 제거하라는 의미에서 발생) 조상클래스만으로 사용.\n키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있으며, 방법은 아래와 같다.\n먼저 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만들고\n키워드 throw를 이용해서 예외 발생\n// throw new Exception(\"고의로 발생시킴\"); --> 위에 두줄을 한줄로 표현\n예외메세지 : 고의로 발생시킴\nChecked Exception vs Unchecked Exception\n// 고의로 Exception을 발생시킨다.\n: unsupported exception java.lang.Exception;\nmust be caught or decalred to be thrown\nExceptionEx10과 같은 경우 에러가 발생하고 컴파일이 완료되지 않는다 예외처리가 되어야 할 부분에 처리가 되어 있지 않다는 에러이다.\n// 고의로 RuntimeException을 발생시킨다.\nExceptionEx11과 같은 경우는 예외처리를 하지 않았음에도 불구하고 컴파일 에러는 생기지 않았다  실행하면 RuntimeException이 발생하여 비정상적으로 종료될 것이다.\n컴파일러가 예외처리를 확인하지 않는 RuntimeException 클래스들은 'unchecked'라고 부르고 예외처리를 확인하는 Exception 클래스들은 'checked'라고 부른다.\n1.7 메서드의 예외 선언하기\n지금까지는 예외를 try-catch문을 사용해서 처리했었는데 예외를 method에 선언하는 방법도 있다.\n아래와 같이 최고조상인 Exception클래스를 메서드에 선언하면 이 메서드는 모든 종류의 예외가 발생할 가능성이 있다는 뜻이다.\n메서드의 선언부에 예외를 선언함으로서 메서드를 사용하려는 사람이 메서드의 선언부를 보았을 때 이 메서드를 사용하지 위해서는 어떠한 예외들이 처리되어져야 하는지 쉽게 알수 있다.\n기존의 많은 다른 언어에서는 볼 수 없는 형태인데, 자바에서는 메서드를 사용하는 쪽에서 예외처리를 하도록 강요하기 때문에 프로그래머들의 짐을 덜어주는 것은 물론이고 보다 견고한 프로그램 코드를 작성할 수 있도록 도와준다.\nJava API에서 찾아본 Object class의 wait() method\nWaits to be notified by another thread of a change in\nThe current thread must own\nThe thread releases ownership of\nmonitor and waits until\nanother thread notifies threads waiting on\nobject's monitor to wake up either through a call to the notify method\nor the notifyAll method.\nThe thread then waits until it can re-obtain ownership of the monitor and resumes execution.\nThis method should only be called by a thread that is the owner of\nSee the notify method\na description of the ways in which a thread can become the owner of a monitor.\nthe current thread is not the owner of the object's monitor.\nanother thread has interrupted\n여기서 의미하는 것은 wait() 메서드를 호출하게 되면 InterruptedException이 발생할 수 있으므로 wait()을 호출하는 메서드에서 InterruptedException을 처리해주어야 한다는 것이다.\n위의 구조에서 볼 수 있듯이 InterruptedException은 Exception의 자손이기 때문에 이는 'checked' Exception 이므로 반드시 처리해주어야 하는 예외임을 알수 있다.\nwait() 메서드는 또한 IllegalMonitorStateException 을 발생시킬 수 있는데 IllegalMonitorStateException은 RuntimeException의 자손이기 때문에 예외처리를 하지 않아도 된다.\n지금까지 본것처럼 메서드의 예외를 선언할때 보통은 RuntimeException클래스들은 적지 않는다.\n적는다고 해서 문제가 되지는 않지만 보통은 반드시 처리해야 할 예외만 적어둔다.\n사실 예외를 메서드의 throws에 명시하는것은 호출하는 메서드에 예외처리를 떠넘기는 것이다.\n예외를 전달받은 메서드가 또다시 자신을 호출한 메서드에게 전달할 수 있으며 이런식으로 계속 호출스택에 있는 메서드들을 따라 전달되다가 제일 마지막에 있는 main 메서드에서도 예외처리가 되지 않으면 main마저 종료되어 프로그램이 종료된다.\n// 같은클래스내의 static 멤버이므로 객체생성 없이 직접 호출 가능\n예외가 발생했을 때 모두 3개의 메서드가 호출스택에 있었으며,\n예외가 발생한 곳은 제일 윗줄에 있는 method2()라는 것과\nmain메서드가 method1()을 그리고 method1()은 method2()를 호출했다는 것을 알 수 있다\nException을 throw 한 곳이 있으면 반드시 어디선가에서는 try-catch문으로 예외처리를 해야 한다.\n// command line에서 입력받은 값을 이름으로 갖는 파일을 생성한다.\nFile f = createFile(args[\n\" 파일이 성공적으로 생성되었습니다.\"\n// fileName이 부적절한 경우, 파일 이름을 '제목없음.txt'로 한다.\n// File클래스의 객체를 만든다.\n// 생성된 객체를 이용해서 파일을 생성한다.\ntest.txt 파일이 성공적으로 생성되었습니다.\n제목없음.txt 파일이 성공적으로 생성되었습니다.\n이 예제는 예외가 발생한 메서드에서 직접 예외를 처리하도록 되어있다 createFile메서드를 호출한 main에서는 예외가 발생한 사실을 알지 못한다.\n적절하지 못한 파일 이름이 입력되면 예외를 발생시키고 finally 블럭에서는 예외의 발생여부에 관계없이 파일을 생성하는 일을 한다\ntry 블럭이 끝날 때 항상 수행되는 블럭\nreturn, continue, 또는 break 등이라도\n1.9 자동 자원 반환 - try-with-resources문\nJava 7 부터 추가된 try-catch문 변형\nSuppressed Exception : try-catch 절에서 예외가 발생하면 AutoCloseable.close() 에서 발생할 수도 있는 예외는 억제된 예외로 처리된다.\n1.10 사용자정의 예외 만들기\n필요에 따라 새로운 예외 클래스를 정의할 수 있다.\n컴파일러에 의해 반드시 예외처리해야 한다.\nIOException, SQLException, DataAccessException, ClassNotFoundException, InvocationTargetException, MalformedURLException, ...\n컴파일러가 확인하지 않으며, 잘못된 개발에 의해 발생하는 예외상황\nNullPointerException, ArrayIndexOutOfBound, IllegalArgumentException, IllegalStateException, ...\n1.11 예외 되던지기 (exception re-throwing)\n예외 전파(회피)를 위해 다시 예외를 발생시키는 방식\n1.12 연결된 예외 (chained exception)\n예외 전환을 위해 다른 예외로 발생시키는 방식"
  },
  {
    "chapter": 8,
    "title": "9. java.lang패키지와 유용한(util) 클래스",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter9.html",
    "content": "9. java.lang패키지와 유용한(util) 클래스\n자바프로그래밍에 가장 기본이 되는 클래스들 포함\nimport문 없이도 사용 가능\n모든 클래스의 최고 조상\nObject클래스의 멤버들은 모든 클래스에서 사용 가능\n멤버변수는 없고 11개의 메서드만 가짐 (인스턴스가 가져야 할 기본적인 것들)\n객체 자신과 객체 obj가 같은 객체 인지 여부를 반환 (같으면 true)\n객체 자신의 해시코드를 반환\n객체 자신의 정보를 문자열로 반환\n객체 자신의 복사본을 반환\n객체 자신의 클래스 정보를 담고 있는 Class인스턴스를 반환\n객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨움\n객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움\npublic void wait(long timeout)\npublic void wait(long timeout, int nanos)\n다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다.\n(timeout은 천 분의 1초, nanos는 109분의 1초)\n객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출\n이 때 수행되어야하는 코드가 있을 때 오버라이딩 (거의 사용안함)\n: notify(), notifyAll(), wait()는 쓰레드(thread) 관련이라 13장에서 자세히 설명\n매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean으로 알려준다.\n두 객체의 같고 다름을 참조변수의 값으로 판단하므로 항상 false\nequals메서드 기본구현 사용 예제\n// 서로 다른 주소 참조\n// 서로 같은 주소 참조\n: 객체를 생성할 때, 메모리의 비어있는 공간을 찾아 생성하므로 서로 다른 두 개의 객체가 같은 주소를 갖는 일은 있을 수 없다.\n두 개 이상의 참조변수가 같은 주소값을 갖는 것(한 객체를 참조하는 것)은 가능하다.\n(p1 == p2) {\n// 서로다른 주소 참조\n// 서로 같은 값\n: equals메서드를 오버라이딩하고 있는 클래스들\nString, Date, File, Wrapper클래스(Integer, Double 등)\n의외로 StringBuffer클래스는 오버라이딩 되어있지 않다.\n해싱(hashing)기법에 사용되는 해시함수(hash function)를 구현한 것\n기본구현: 객체의 주소값을 이용해서 해시코드를 만들어 반환한다.\n따라서, 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없다.\n오버라이딩: 클래스의 인스턴스변수값으로 객체의 같고 다림을 판단해야할 경우\n: 데이터관리기법 중의 하나로 다량의 데이터를 저장하고 검색하는데 유용\n: 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환\n해싱기법을 사용하는 HashMap이나 HashSet과 같은 클래스에 저장할 객체라면 반드시 hashCode메서드를 오버라이딩해야 한다.\n(자세한 것은 11장 컬렉션 프레임웍에서)\nhashCode메서드 오버라이딩 예제: String클래스\n객체의 주소값을 해시코드로 생성\n모든 객체에 대해 항상 다른 해시코드값을 반환할 것을 보장\n호출결과는 실행 할 때마다 달라질 수 있음\n인스턴스에 대한 정보를 문자열(String)으로 제공할 목적으로 정의\n대부분의 경우 인스턴스 변수에 저장된 값들을 문자열로 표현\ntoString메서드 기본구현 사용 예제\n// 조상클래스(Object)에 정의된 접근범위보다 같거나 넓어야 하므로, public\n\", number : \"\n// kind : SPADE, number : 1\n// kind : HEART, number : 2\n: String, Date클래스도 toString메서드가 오버라이딩 되어 있음\n자신을 복제하여 새로운 인스턴스를 생성\n작업 실패시 원래 상태로 되돌리거나 변경되기 전의 값을 참고하는데 도움\n기본구현: 단순히 인스턴스 변수의 값만 복사\n따라서, 참조변수 타입의 인스턴스 변수가 정의되어 있는 경우 완전한 복제가 아님\n공변 반환타입(covariant return type)\n오버라이딩할 때 조상 메서드의 반환타입을 자손 클래스 타입으로 변경을 허용 (jdk1.5부터)\n반환타입을 Object -> Point (조상->자손타입으로) 변경\n(CloneNotSupportedException e) { }\n// Point copy = (Point)original.clone();\nPoint copy = original.clone();\n// 번거로운 형변환이 줄어든다.\n배열도 객체이기 때문에 Object클래스를 상속받으며, Clonable인터페이스와 Serializable인터페이스가 구현되어 있다.\njava.util패키지의 Vector, ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, Calendar, Date와 같은 클래스들도 이와 같은 방식으로 복제가 가능하다.\n[] arr = {\n//int[] arrClone = new int[arr.length];\n[] arrClone = arr.clone();\n얕은 복사와 깊은 복사\n: 단순히 객체에 저장된 값을 그대로 복제할 뿐, 객체가 참조하고 있는 객체까지 복사하지 않는다.\n(원본과 복제본이 같은 객체를 공유하므로 완전한 복제가 아니며, 원본을 변경하면 복사본도 영향을 받는다.)\n: 원본이 참조하고 있는 객체까지 복사한다.\n(원본과 복사본이 서로 다른 객체를 참조하기 때문에 원본의 변경이 복사본에 영향을 미치지 않는다.)\n// 원점 - 참조변수\n// 복제본이 원본과 동일한 Point인스턴스를 참조하게 된다.\nCircle c = (Circle)obj;\n// 복제본이 새로운 Point인스턴스를 참조하도록 한다.\nCircle c1 = Circle(\nCircle c2 = c1.clone();\n// 얕은 복사: 동일한 Point 주소를 참조하는 p를 갖는다.\n자신이 속한 클래스의 Class객체를 반환\n이름이 'Class'인 클래스의 객체\n클래스의 모든 정보(정의된 멤버의 이름이나 개수 등)를 담고 있고, 클래스당 단 1개만 존재\n클래스 파일이 '클래스 로더(ClassLoader)'에 의해 메모리에 올라갈 때, 자동생성\n실행시에 필요한 클래스를 동적으로 메모리에 로드하는 역할\n기존에 생성된 클래스 객체가 메모리에 존재하는지 확인\n클래스패스(classpath)에 지정된 경로를 따라서 클래스 파일 찾음\n해당 클래스를 못찾으면 ClassNotFoundException 발생\n// 생성된 객체로부터 얻음\n// 클래스 리터럴(*.class)로부터 얻음\nClass cObj = Card.class;\n// 클래스 이름으로부터 얻음\n// 특정 클래스 파일을 메모리에 올릴때 주로 사용 (예: 데이터베이스 드라이버)\nClass cObj = Class.forName(\nClass객체를 이용해서 동적으로 객체를 생성하는 방법\n// new연산자를 이용해서 객체 생성\n// Class객체를 이용해서 객체 생성\n// InstantiationException 예외처리 필요\nCard c = Card.class.newInstance();\n: 동적으로 객체를 생성하고 메서드를 호출하는 방법에 대해 더 알고싶다면, '\n문자열을 저장하고 이를 다루는데 필요한 메서드를 제공한다.\n인스턴스변수로 문자형 배열 변수에 문자열을 저장한다.\n클래스앞에 final이 붙으므로 다른 클래스의 조상이 될 수 없다.\n한번 생성된 String 인스턴스가 갖고 있는 문자열은 읽어올 수만 있고, 변경할 수는 없다.\n'+' 연산자를 이용해서 문자열을 결합하는 경우 인스턴스내의 문자열이 바뀌는 것이 아니라 새로운 문자열이 담긴 String 인스턴스가 생성되는 것이다.\n(결합시마다 인스턴스가 생성되어 메모리 공간을 차지하므로 횟수를 줄이는 것이 좋다.)\n문자열간의 결합이나 추출 등의 작업은 StringBuffer클래스를 사용하는 것이 좋다.\n자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다.\n문자열 리터럴도 String인스턴스이고 한번 생성하면 내용을 변경할 수 없기 때문에 하나의 인스턴스를 공유한다.\n클래스 파일에는 소스파일에 포함된 모든 리터럴의 목록이 있다.\n클래스로더에 의해 메모리에 올라갈 때, 리터럴들이 JVM내에 있는 '상수저장소(constant pool)'에 저장된다.\n길이가 0인 char형 배열\n// 빈문자열로 초기화 (null보다는 이렇게 초기화)\n// char형 변수에는 반드시 하나의 문자를 지정해야 함\n: c언어에서는 문자열의 끝에 널 문자가 항상 붙지만, 자바에서는 널 문자를 사용하지 않는다.\n대신 문자열의 길이정보를 따로 저장한다.\nString클래스의 생성자와 메서드: p468  p471 참고\njoin(): 여러 문자열 사이에 구분자를 넣어서 결합한다.\nsplit(): 구분자로 문자열을 자른다.\njava.util.StringJoiner클래스로 문자열을 결합할 수도 있다.\nString[] arr = animals.split(\nString str = String.join(\nString[] strArr = {\n(String s : strArr)\nString클래스 메서드 중에 보충 문자를 지원하는 경우 매개변수로 int를 받는다.\n보충 문자를 사용할 일은 거의 없기 때문에 이정도만 알아둔다.\n: 유니코드는 원래 2byte(16bit) 문자체계인데 20bit로 확장하게되었다.\n그래서 하나의 문자를 char타입으로 다루지 못하고 int타입으로 다룰 수 밖에 없다.\ngetBytes(String chartsetName)를 사용하여 문자열의 문자 인코딩을 다른 인코딩으로 변경할 수 있다.\n자바가 UTF-16를 사용하지만, 문자열 리터럴에 포함되는 문자들은 OS의 인코딩을 사용한다.\n// 문자열을 UTF-8로 변환\n// byte배열을 문자열로 변환\n한글 윈도우즈 문자 인코딩: CP949\nUTF-8은 한글 한글자를 3byte로 표현하고, CP949는 2byte로 표현한다.\n사용가능한 문자 인코딩 목록: java.nio.charset.Charset.availableCharsets()\nString str = String.format(\n\"d 더하기 d는 d입니다.\"\n// 3 더하기 5는 8입니다.\n기본형 값을 String으로 변환\nString str1 = i +\n// 100 -> \"100\"\nString str2 = String.valueOf(i);\n// 100 -> \"100\" (성능향상이 필요한 경우)\nString을 기본형 값으로 변환\n: 변환시 예외발생에 대해 적절히 처리해주어야 한다.\n: 문자열 양끝의 공백제거\nsubstring(int start, int end)\n: 한 문자열에서 내용의 일부를 추출한다.\n각 문자의 위치를 뜻하는 index가 0부터 시작한다.\nend 위치는 포함되지 않는다.\nString a = str.substring(\nString b = str.substring(\n1.3 StringBuffer클래스와 String Builder클래스\n문자열을 변경할 수 있도록 내부적으로 편집을 위한 버퍼(buffer)를 가진 클래스\nStringBuffer인스턴스를 생성할 때 그 크기를 지정할 수 있다.\n편집할 문자열의 길이를 고려하여 버퍼의 길이를 충분히 잡아주는 것이 좋다.\n문자열이 버퍼의 길이를 넘어서게되면 길이를 늘려주는 작업이 수행되어야 한다.\nString클래스와 같이 문자열을 저장하기 위한 char형 배열 참조변수를 인스턴스로 갖는다.\n인스턴스 생성시 적절한 길이의 char형 배열이 생성되고, 이 배열은 문자열을 저장하고 편집하기 위한 공간으로 사용된다.\n// 버퍼의 크기를 정하지 않으면 16으로 잡는다.\n// 버퍼의 크기를 지정한 문자열의 길이보다 16 크게 잡는다.\n/* 버퍼의 크기를 늘리는 작업 코드 */\n// 새로운 길이의 배열을 생성 (newCapacity는 정수값)\n// 기존 내용 복사\n// count = 문자열 길이\n// 새로 생성된 배열의 주소를 참조변수 value에 저장\n// sb의 내용 뒤에 123을 추가하고 자신의 주소를 반환한다.\nStringBuffer sb2 = sb.append(\n// sb의 내용 뒤에 ZZ를 추가하고 자신의 주소를 반환한다.\n// equals()는 오버라이딩 되어있지 않음.\n// toString()은 오버라이딩 되어 있음.\nString s = sb.toString();\nString s2 = sb2.toString();\nStringBuffer클래스의 생성자와 메서드: p480  p481 참고\nStringBuffer는 멀티쓰레드에 안전(thread safe)하도록 동기화 되어 있다.\nStringBuilder: StringBuffer에서 쓰레드의 동기화만 뺀 클래스 (그외에는 완전 똑같은 기능)\n멀티쓰레드 환경이 아니라면 StringBuilder를 쓰면된다.\nStringBuffer도 충분히 성능이 좋기 때문에 성능향상이 반드시 필요한 경우에만 쓴다.\n기본적인 수학계산에 유용한 메서드로 구성된 클래스\n생성자가 private이므로 다른 클래스에서 인스턴스를 생성할 수 없다.\n(인스턴스변수가 하나도 없어서 인스턴스를 생성할 필요가 없다.)\n2개의 상수만 정의되어 있다.\nround(): 항상 소수점 첫째자리에서 반올림을 해서 정수값(long)을 결과로 돌려준다.\n원하는 자리 수에서 반올림된 값을 얻기 위해서는 10의 n제곱으로 곱한 후 다시 곱한 수로 나눠준다.\n// 원래값에 100을 곱한다.\n// 위의 결과에 Math.round()를 사용한다.\n// 위의 결과에 다시 100.0(정수형으로 나누면 90이 됨)으로 나눈다.\nExact가 포함된 메서드들 (jdk1.8부터 새로 추가됨)\n정수형 연산에서 발생할 수 있는 오버플로우(overflow)를 감지한다.\n오버플로우가 발생하면 ArithmeticException 예외를 발생시킨다.\n// x + y\n// x - y\n// x * y\n// (int)value - int 로의 형변환\nMath클래스에는 수학 관련 메서드들이 많이 있다.\n자세한 내용은 Java API를 참고\n어떤 OS에서 실행되어도 항상 같은 결과를 얻도록 Math클래스를 새로 작성한 것\n: Math클래스는 성능 이슈로 JVM이 설치된 OS의 메서드를 호출해서 사용하기 때문에 OS에 의존적이다.\nMath클래스의 메서드: p489  p490 참고\nstatic double abs(double a)\nstatic float abs(float f)\nstatic int abs(int f)\nstatic long abs(long f)\n주어진 값의 절대값을 반환\nstatic double ceil(double a)\n주어진 값을 올림하여 반환\nstatic double floor(double a)\n주어진 값을 버림하여 반환\nstatic double max(double a, double b)\nstatic float max(float a, float b)\nstatic int max(int a, int b)\nstatic long max(long a, long b)\n주어진 두 값을 비교하여 큰 쪽을 반환\nstatic double min(double a, double b)\nstatic float min(float a, float b)\nstatic int min(int a, int b)\nstatic long min(long a, long b)\n주어진 두 값을 비교하여 작은 쪽을 반환\n0.0  1.0 범위의 임의의 double값을 반환 (1.0은 범위에 포함되지 않는다.)\nstatic double rint(double a)\n주어진 double값과 가장 가까운 정수값을 double형으로 반환\nstatic long round(double a)\nstatic long round(float a)\n소수점 첫째자리에서 반올림한 정수값(long)을 반환 (매개변수의 값이 음수인 경우, round()와 rint()의 결과가 다르다.)\n기본형(primitive type)을 클래스로 다루어야 할 경우를 위한 클래스\n래퍼클래스들은 모두 equals(), toString()이 오버라이딩 되어 있다.\n비교연산자를 사용할 수 없는 대신 compareTo()를 제공한다.\nBoolean b = new Boolean(true);\nBoolean b2 = new Boolean(\"true\");\nCharacter c = new Character('a');\nByte b = new Byte(10);\nByte b2 = new Byte(\"10\");\nShort s = new Short(10);\nShort s2 = new Short(\"10\");\nInteger i = new Integer(100);\nInteger i2 = new Integer(\"100\");\nLong l = new Long(100);\nLong l2 = new Long(\"100\");\nFloat f = new Float(1.0);\nFloat f2 = new Float(1.0f);\nFloat f3 = new Float(\"1.0f\");\nDouble d = new Double(1.0);\nDouble d2 = new Double(\"1.0\");\n: 래퍼클래스의 생성자는 매개변수로 문자열이나 각 자료형의 값들을 인자로 받는다.\n각 자료형에 알맞은 타입을 사용하지 않으면 FormatException이 발생한다.\n추상클래스로 내부적으로 숫자를 멤버변수로 갖는 래퍼클래스들의 조상\n객체가 가지고 있는 값을 숫자와 관련된 기본형으로 변환하여 반환하는 메서드들을 정의하고 있다.\nBigInteger: long으로도 다룰 수 없는 큰 범위의 정수\nBigDecimal: double로도 다룰 수 없는 큰 범위의 부동 소수점수\nBoolean - Character - Number\nByte - Short - Integer - Long - Float - Double - BigInteger - BigDecimal\n/* Number클래스의 실제 소스 */\n// floatVlaue(), longValue(), ...\n// 주로 이 방법을 많이 사용\nInteger i3 = Integer.valueOf(\nbyte b = Byte.parseByte(\"100\");\nByte b = Byte.valueOf(\"100\");\nshort s = Short.parseShort(\"100\");\nShort s = Short.valueOf(\"100\");\nint i = Integer.parseInt(\"100\");\nInteger i = Integer.valueOf(\"100\");\nlong l = Long.parseLong(\"100\");\nLong l = Long.valueOf(\"100);\nfloat f = Float.parseFloat(\"3.14\");\nFloat f = Float.valueOf(\"3.14\");\ndouble d = Double.parseDouble(\"3.14\");\nDouble d = Double.valueOf(\"3.14\");\n: jdk1.5부터 도입된 오토박싱(autoboxing) 기능 때문에 반환값이 기본형일 때와 래퍼 클래스일 때의 차이가 없어졌다.\n그래서 그냥 구별없이 valueOf()를 쓰는 것도 괜찮다.\n단, 성능은 valueOf()가 조금 더 느리다.\n// 100(2) -> 4\n// 100(8) -> 64\n// 100(16) -> 256\n// FF(16) -> 255\n오토박싱  언박싱 (autoboxing  unboxing)\njdk1.5에 추가된 기본형과 참조형 간의 연산이 가능하도록 컴파일러가 자동으로 변환하는 기능 (이전에는 형변환해야했음)\n오토박싱(autoboxing): 기본형값을 래퍼클래스의 객체로 자동변환\n언박싱(unboxing): 래퍼클래스를 기본형값으로 자동변환\nint i = 5;\nInteger iObj = new Integer(7);\nint sum = i + iObj;\nint sum = i + iObj.intValue();\n// 오토박싱: 10 -> new Integer(10)\n// 언박싱: new Integer(10) -> 10\nObject 클래스의 보조 클래스로 Math 클래스처럼 모든 메서드가 'static'이다.\n객체의 비교나 널 체크에 유용하다.\n난수를 얻는 방법을 생각하면 Math.random()이 떠오를 것이다.\n이 외에도 Random 클래스를 사용하면 난수를 얻을 수 있다.\n사실 Math.random()은 내부적으로 Random 클래스의 인스턴스를 생성해서 사용하는 것이므로 둘 중에서 편한 것을 사용하면 된다.\n2.3 정규식(Regular Expression) - java.util.regex 패키지\n정규식이란 텍스트 데이터 중에서 원하는 조건(패턴, pattern)과 일치하는 문자열을 찾아내기 위해 사용하는 것으로 미리 정의된 기호와 문자를 이용해서 작성한 문자열을 말한다.\n이거 문자 파싱할 때 자주 쓰는데요-\nD. html 에서 텍스트 마이닝\nString[] data = {\nPattern p = Pattern.compile(\nMatcher m = p.matcher(data[i]);\n단계별로 설명하면 아래의 스텝을 거친다.\n정규식을 매개변수로 Pattern클래스의 static 메서드인 Pattern compile(String regex)을 호출하여 Pattern 인스턴스를 얻는다.\n정규식으로 비교할 대상을 매개변수로 Pattern클래스의 Matcher matcher (CharSequence input)를 호출해서 Matcher인스턴스를 얻는다.\nMatcher 인스턴스에 boolean matches()를 호출해서 정규식에 부합하는 지\nc로 시작하는 두자리 영단어\nc로 시작하는 두자리 영단어 (az 또는 AZ)\nc로 시작하고 숫자와 영어로 조합된 두 글자\nc로 시작하는 두 자리\nc로 시작하는 모든 문자열(기호포함)\n'은 패턴작성에 사용되는 문자이므로 escape문자인 ''를 사용해야 한다.\nc와 숫자로 구성된 두자리 문자열\nc로 시작하고 t로 끝나는 모든 문자열\nb나 c로 시작하는 문자열\nb나 c로 시작하지 않는 문자열\na를 포함하는 모든 문자열\nb 또는 c로 시작하는 세자리 문자열\nScanner는 화면, 파일, 문자열과 같은 입력소스로부터 문자데이터를 읽어오는데 도움을 줄 목적으로 JDK 1.5부터 추가되었다.\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\nString input = br.readLine();\nString input = s.nextLine();\nConsole console = System.console();\nString input = console.readLine();\nStringTokenizer는 긴 문자열을 지정된 구분자를 기준으로 토큰(token)이라는 여러개의 문자열로 잘라내는 데 사용된다.\n예를 들어 \"100,200,300,400\"라는 문자열이 있을 때 ','를 구분자로 잘라내면 100, 200, 300, 400 이라는 4개의 문자열을 얻을 수 있다.\nStringTokenizer(String str, String delim)\n문자열(str)을 지정된 구분자(delim)로 나누는 StringTokenizer를 생성한다.\nStringTokenizer(String str, String delim, boolean returnDelims)\n전체 토큰의 수를 반환한다.\n정수형으로 표현할 수 있는 값의 한계가 있다.\n가장 큰 정수형 타입인 long으로 표현할 수 있는 값은 10진수로 19자리 정도이다.\n이 값도 상당히 큰 값이지만, 과학적 계산에서는 더 큰 값을 다뤄야 할 때가 있다.\n그럴 때 사용하면 좋은 것이 BigInteger이다.\nDouble 타입으로 표현할 수 있는 값은 상당히 범위가 넓지만, 정밀도가 최대 13자리 밖에 되지 않고 실수형의 특성상 오차를 피할 수 없다.\nBigDecimal은 실수형과 달리 정수를 이용해서 실수를 표현한다.\n앞에서 배운 것과 같이 실수의 오차는 10진 실수를 2진 실수로 정확히 변환할 수 없는 경우가 있기 때문에 발생하는 것이므로, 오차가 없는 2진 정수로 변환하여 다루는 것이다.\n실수를 정수와 10의 제곱의 곱으로 표현한다.\n정수 x 10  scale"
  },
  {
    "chapter": 9,
    "title": "Chapter 10 날짜와 시간 & 형식화",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter10.html",
    "content": "Chapter 10 날짜와 시간  형식화\n사용하기 매우 불편해 대체되는 오프소스 라이브러리\n결국, jdk8에서 joda-time 라이브러리를 수용\nJoda-Time provides a quality replacement for the Java date and time classes.\nJoda-Time is the de facto standard date and time library for Java prior to\nUsers are now asked to migrate to java.time (JSR-310).\nCalendar cal = Calendar.getInstance();\n(TimeZone zone, Locale aLocale)\nString caltype = aLocale.getUnicodeLocaleType(\nCalendar date = Calendar.getInstance();\n//2016.3.7 로 설정 month   the month between 0-11.\n//date.add(Calendar.JUNE, 2) compile ok.\nApache Common Lang (DateUtils)\nDate tomorrow = DateUtils.addDays(now,\nDate tomorrowAnd2Min = DateUtils.addSeconds(tomorrow,\n본인(Clint)는 주로 날짜/시간을 저장할 경우 Long 타입으로 저장합니다.\n이유는 Zone, Parsing 등 편하기 때문입니다.\n// long 형의 현재시간\nString str = df.format(today);\napi 제공시, javascript에서 변환이 편함.\n{{ conn.created  date : 'yyyy.MM.dd HH:mm:ss' }}\nNumber num = df.parse(\nString result = sdf.format(\nDate result2 = sdf2.parse(\n특정범위에 속하는 값을 형식화\nLocalDateTime + 시간데 -> ZoneDateTime\n기본적인거는 LocalDate와 LocalTime과 동일\n시간대는 기존에는 TimeZone클래스를 사용했으나 ZoneId라는 클래스가 생김\nZoneId는 일광 절약시간(DST, Daylight Saving Time)을 자동적으로 처리해 주므로 더 편리하다.\n일광 절약시간 = summer time 낮 시간이 길어지는 봄부터 시곗바늘을 1시간 앞당겼다가 낮 시간이 짧아지는 가을에 되돌리는 제도\nZoneOffset은 UTC로부터 얼마만큼 떨어져 있는지를 표현한다.\nOffsetDateTime은 시간대를 시간의 차이로만 구분하며 서로 다른 시간대에서 데이터를 주고받을때 시간을 표현하기에 적합하다.\n자주 쓰일만한 날짜 계산들을 대신해주는 메서드를 정의해 놓은 클래스\nLocalDate today = LocalDate.now();\nLocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));\nTemporalAdjuster의 adjustInto()를 구현함으로써 직접 만들 수 있으나 사용은 클래스의 with()를 통해서 사용한다\nwith() 내부에서 adjustInto() 호출\n날짜 - 날짜 = Period\n시간 - 시간 = Duration\n(LocalDate startDateInclusive, LocalDate endDateExclusive)\nLocalDate end = LocalDate.from(endDateExclusive);\ntotalMonths = end.getProlepticMonth() -\ndays = end.day -\n) (end.toEpochDay() - calcDate.toEpochDay());\nyears = totalMonths /\nbetween과 until을 위에 있는거 처럼 같은일을 하나 between()은 static메서드 이고, until()은 인스턴스 메서드라는 차이가 있다.\n(Temporal startInclusive, Temporal endExclusive)\n(DateTimeException  ArithmeticException ex) {\nsecs = startInclusive.until(endExclusive, SECONDS);\nnanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);\nof(), with(), plus(), minus(), negate(), abs(), toXXX()\n형식화와 관련된 클래스들은 java.time.format패키지에 들어있는데 그중에서 DataTimeFormatter가 핵심이다 p.572참고\nDateTimeFormatter의 static메서드 ofLocalizeDate(), ofLocalizedTime(), ofLocalizedDateTime()은\n로케일(locale)에 종속적인 포맷터를 생성한다.\nDateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);\nString shortFormat = formatter.format(LocalDate.now());\n2015년 11월 28일 토요일\n2015년 11월 28일 (토)\n오후 9시 15분 13초\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\n문자열을 날짜와 시간으로 파싱하기\n(CharSequence text, DateTimeFormatter formatter)"
  },
  {
    "chapter": 10,
    "title": "Chapter 11 컬렉션 프레임웍",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter11.html",
    "content": "Chapter 11 컬렉션 프레임웍\n데이터 군을 저장하는 클래스들을 표준화한 설계.\n1.1 컬렉션 프레임웍의 핵심 인터페이스\n컬렉션 프레임웍의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현\n[표11-1] 컬렉션 프레임웍의 핵심 인터페이스와 특징\n순서가 있는 데이터의 집합.\n순서를 유지하지 않는 데이터의 집합.\n데이터의 중복을 허용하지 않음\n키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합.\n순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용\n컬렉션 클래스들의 이름 특징\n구현한 인터페이스 이름이 클래스의 이름에 포함\nVector, Stack, Hashable, Properties와 같은 클래스들은 컬렉션 프레임웍이 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임웍의 명명법을 따르지 않음\nVector나 Hashable과 같은 기존의 컬렉션 클래스들은 가능하면 사용하지 않는 것이 좋음\n대신 새로 추가된 ArrayList와 HashMap 사용 권장\nList와 Set의 조상으로 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 메서드들을 정의\n[표11-2] Collection인터페이스에 정의된 메서드\n지정된 객체 또는 Collection의 객체들을 Collection에 추가\nCollection의 모든 객체를 삭제\n지정된 객체 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인\nCollection의 hash code를 반환\nCollection의 iterator를 얻어서 반환환\n지정된 객체 또는 Collection에 포함된 객체들을 삭제\n지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제\n저장된 객체의 개수를 반환\n저장된 객체를 객체 배열(Object[])로 반환\n중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용\nvoid add(int index, Object element) boolean addAll(int index, Collection c)\n지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가\n지정된 위치(index)에 있는 객체 반환\n객체의 위치(index) 반환(List의 첫 번째 요소부터 순방향으로 찾음)\n객체의 위치(index)를 반환(List의 마지막 요소부터 역방향으로 찾음)\nList의 객체에 접근할 수 있는 ListIterator를 반환\n지정된 위치에 있는 객체를 삭제하고 삭제된 객체를 반환\nObject set(int index, Object element)\n지정된 위치에 객체를 저장\nList subList(int fromIndex, int toIndex)\n지정된 범위에 있는 객체를 반환\n중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용\n키(key)와 값(value)을 하나의 쌍으로 묶어서 저장.\n키는 중복될 수 없지만 값은 중목을 허용.\n중복된 키와 값을 저장하면 기존의 값은 없어지고 마지막에 저장된 값이 남음\nMap인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection타입으로 반환하고 키(key)는 중복을 허용하지 않기 때문에 Set타입으로 반환\nMap에 저장되는 key-value쌍을 다루기 위해서 Map인터페이스의 내부 인터페이스로 인터페이스 안에 인터페이스를 정의\nEntry의 value객체를 지정된 객체로 바꿈\n가장 많이 사용되는 컬렉션 클래스\n데이터의 저장순서가 유지되고 중복을 허용\n기존의 Vector와 구현원리와 기능적인 측면에서 동일하지만 가능하면 Vector보다는 ArrayList를 사용\nObject배열을 이용해서 데이터를 저장하는데 배열에 저장 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장\n[ArrayList의 소스코드 일부 - Object배열]\nArrayList 생성 시, 실제 저장할 개수보다 약간 여유있는 크기로 하는 것이 좋다.\n생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만 이 과정에서 처리시간이 많이 소요되기 때문이다.\n//크기를 약간 여유있게 잡는다.\nArrayList나 Vector 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야하기 때문에 상당히 효율이 떨어진다는 단점이 있다.\n그래서 처음에 인스턴스를 생성할 때, 저장할 데이터의 개수를 잘 고려하여 충분한 용량의 인스턴스를 생성하는 것이 좋다.\nList인터페이스 중 remove의 경우 이해하기 어려울 수도 있기 때문에 단계별로 설명한다.\n삭제할 데이터의 아래에 있는 데이터를 한 칸씩 위로 복사해서 삭제할 데이터를 덮어쓴다.\n// data[3]에서 data[2]로 2개의 데이터를 복사하라는 의미\n데이터가 모두 한 칸씩 위로 이동하였으므로 마지막 데이터는 null로 변경해야 한다.\n데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 1 감소시킨다.\n위 과정을 통해 배워야 할 것은\n배열에 객체를 순차적으로 저장할 때와 객체를 마지막에 저장된 것부터 삭제하면 System.arraycopy()를 호출하지 않기 때문에 작업시간이 짧지만, 배열의 중간에 위치한 객체를 추가하거나 삭제하는 경우 System.arraycopy()를 호출해서 다른 데이터의 위치를 이동시켜 줘야 하기 때문에 다루는 데이터의 개수가 많을수록 작업시간이 오래 걸린다는 것이다.\n크기를 변경할 수 없다.\n- 크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요하다.\n- 실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.\n비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.\n- 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만,\n- 배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.\n배열의 단점을 보완하기 위해 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.\n링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.\n// 다음 요소의 주소를 저장\n삭제하고자 하는 요소의 이전요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경하기만 하면 된다.\n배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 처리속도가 매우 빠르다.\n추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경해주고, 새로운 요소가 그 다음 요소를 참조하도록 변경하기만 하면 되므로 처리속도가 매우 빠르다.\n더블 링크드 리스트(이중 연결리스트, doybly linked list)\n링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어렵다.\n이 점을 보완한 것이 더블 링크드 리스트이다.\n더블 링크드 리스트는 단순히 링크드 리스트에 참조변수를 하나 더 추가하여 다음 요소에 대한 참조뿐 아니라 이전 요소에 대한 참조가 가능하도록 했을 뿐, 그 외에는 링크드 리스트와 같다.\n// 이전 요소의 주소를 저장\n실제로 LinkedList 클래스는 이름과 달리 링크드 리스트가 아닌 더블 써큘러 링크드 리스트로 구현했는데, 이는 링크드 리스트의 단점인 낮은 접근성을 높이기 위한 것이다.\n순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다.\n중간에 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.\n예제에서는 ArrayList와 LinkedList의 차이를 비교하기 위해 데이터의 개수를 크게 잡았는데, 사실 데이터의 개수가 그리 크지 않다면 어느 것을 사용해도 큰 차이가 나지는 않는다.\n그래도 ArrayList와 LinkedList의 장단점을 잘 이해하고 상황에 따라 적합한 것을 선택해서 사용하는 것이 좋다.\n배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문에 간단한 계산만으로 원하는 n번째 데이터의 주소를 얻어서 저장된 데이터를 곧바로 읽어올 수 있지만 LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있다.\n그래서 LinkedList는 저장해야하는 데이터의 개수가 많아질수록 데이터를 읽어오는 시간, 즉 접근시간이 길어진다는 단점이 있다.\n[표11-8] ArrayList와 LinkedList의 비교\n순차적인 추가삭제는 더 빠름.\n데이터가 많을수록 접근성이 떨어짐\n데이터의 개수가 변하지 않을 경우라면, ArrayList가 최상의 선택이 되겠지만, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는 것이 더 나은 선택이 될 것이다.\nStack과 Queue의 기본 개념과 특징\n스택은 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)\n큐는 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out)\n그렇다면 스택과 큐를 구현하기 위해서는 어떤 컬렉션 클래스를 사용하는 것이 좋을까?\n순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열기반의 컬렉션 클래스가 적합하지만, 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 적합하다.\n자바에서는 스택을 Stack클래스로 구현하여 제공하고 있지만 큐는 Queue인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있지 않다.\n대신 Queue 인터페이스를 구현한 클래스들이 있어서 이 들 중의 하나를 선택해서 사용하면 된다.\nQueue인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다는 특징이 있다.\n그리고 null은 저장할 수 없다.\nnull을 저장하면 NullPointerException이 발생한다.\n저장공간으로는 배열을 사용하며, 각 요소를 힙(heap)에 저장하며 힙은 잠시 뒤에 배울 이진 트리의 한 종류이다.\nQueue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, Deque(덱 또는 디큐라고 읽음)은 양쪽 끝에 추가/삭제가 가능하다.\n덱은 스택과 큐를 하나로 합쳐놓은 것과 같으며 스택으로 사용할 수도 있고, 큐로 사용할 수도 있다.\n1.5 Iterator, ListIterator, Enumeration\nIterator, ListIterator, Enumeration은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는  인터페이스이다.\nEnumeration은 Iterator의 구버전이며, ListIterator는 Iterator의 기능을 향상 시킨 것이다.\n컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator인터페이스를 정의하고, Collection인터페이스에는 Iterator(Iterator를 구현한 클래스의 인스턴스)를 반환하는 iterator()를 정의하고 있다.\niterator()는 Collection인터페이스에 정의된 메서드이므로 Collection인터페이스의 자손인 List와 Set에도 포함되어 있다.\n그래서 List나 Set인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어 있다.\nIterator는 반복문, 주로 while문을 사용해서 컬렉션 클래스의 요소들을 읽어 올 때 사용된다.\nIterator를 이용해서 컬렉션의 요소를 읽어오는 방법을 표준화하는 것은 코드의 재사용성을 높이는데 사용될 수 있다.\n읽어올 요소가 남아있는지 확인한다.\n있으면 true, 없으면 false를 반환한다.\n다음 요소를 읽어 온다.\nnext()를 호출하기 전에 hasNext()를 호출해서 읽어올 요소가 있는지 확인하는 것이 안전하다.\nnext()로 읽어 온 요소를 삭제한다.\nnext()를 호출한 다음에 remove()를 호출해야 한다.\nEnumeration은 컬렉션 프레임웍이 만들어지기 이전에 사용하던 것으로 Iterator의 구버전이라고 생각하면 된다.\n이전 버전으로 작성된 소스와의 호환을 위해서 남겨두고 있을 뿐이므로 가능하면 Enumeration대신 Iterator를 사용하자.\nEnumeration - Iterator의 구버전\nListIterator - Iterator에 양방향 조회기능추가\nArrays클래스에는 배열을 다루는데 유용한 메서드가 정의되어 있다.\n배열의 복사 - copuOf(), copyOfRange()\ncopyOf()는 배열 전체를,copyOfRange()는 배열의 일부를 복사해서 새로운 배열을 만들어 반환한다.\n배열 채우기 - fill(), setAll()\nfill()은 배열의 모든 요소를 지정된 값으로 채운다.\nsetAll()은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다\n배열의 정렬과 검색 - sort(), binarySearch()\nsort()는 배열을 정렬할 때, 그리고 배열에 저장된 요소를 검색할 때는 binarySearch()를 사용한다.\nbinarySearch()는 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환하는데, 반드시 배열이 정렬된 상태이어야 올바른 결과를 얻는다.\n그리고 만일 검색한 값과 일치하는 요소들이 여러 개 있다면, 이 중에서 어떤 것의 위치가 반환될지는 알 수 없다.\n문자열의 비교와 출력 - equals(), toString()\ntoString()은 모든 요소를 문자열로 출력하는데 일차원 배열에만 사용할 수 있으므로, 다차원 배열에는 deepToString()을 사용해야 한다.\nequals는 두 배열에 저장된 모든 요소를 비교해서 가으같으면 true, 다르면 false를 반환한다.\nequals도 일차원 배열에서만 사용가능하므로, 다차원 배열의 비교에는 deepToEquals()를 사용해야 한다.\n배열을 List로 변환 - asList(Object... a)\nasList()는 배열을 List에 담아서 반환한다.\n'parallel'로 시작하는 이름의 메서드들이 있는데 이 메서드들은 보다 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 한다.\nspliterator()는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환하며 stream()은 컬렉션을 스트림으로 변환한다.\nComparator와 Comparable은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있으며, Comparator와 Comparable의 실제 소스는 다음과 같다.\n(Object o1, Object o2)\ncompare()와 compareTo()는 선언형태와 이름이 약간 다를 뿐 두 객체를 비교한다는 같은 목적으로 고안된 것이다.\ncompareTo()의 반환값은 int지만 실제로 두 객체가 같으면 0, 비교하는 값보다 작으면 음수, 크면 양수를 반환하도록 구현해야 한다.\n이와 마찬가지로 compare()도 객체를 비교해서 음수, 0, 양수 중의 하나를 반환하도록 구현해야 한다.\n아래 코드는 Integer클래스의 일부이다.\nComparable의 compareTo(Object o)를 구현해 놓은 것을 볼 수 있다.\n두 Integer객체에 저장된 int값(value)을 비교해서 같으면 0, 크면 -1, 작으면 1을 반환하는 것을 알 수 있다.\n// 비교하는 값이 크면 -1, 같으면 0, 작으면 1을 반환한다.\nComparable을 구현한 클래스들이 기본적으로 오름차순으로 정렬되어 있지만, 내림차순으로 정렬한다던가 아니면 다른 기준에 의해서 정렬되도록 하고 싶을 때 Comparator를 구현해서 정렬기준을 제공할 수 있다.\nComparable - 기본 정렬기준을 구현하는데 사용.\nComparator - 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용.\n간단한 예제를 통해서 실제로 어떻게 사용되는지 확인해 보자.\npublic static void main(String[] args) {\nString[] strArr = {\"cat\", \"Dog\", \"lion\", tiger\"};\n// Dog, cat, lion, tiger\n// cat, Dog, lion, tiger\n// tiger, lion, cat, Dog\nclass Descending implements Comparator {\npublic int compare(Object o1, Object o2) {\nif(o1 instanceof Comparable  o2 instanceof Comparable) {\nComparable c1 = (Comparable)o1;\nComparable c2 = (Comparable) o2;\nreturn c1.compareTo(c2) * -1; // -1을 곱해서 기본 정렬방식의 역으로 변경\n내부적으로 HashMap을 이용해서 만들어졌으며, Hashing 기법을 이용해서 구현한 Set인터페이스이다.\nHashSet에 요소를 추가할 때\nHashSet에 요소를 추가할 때는 add 또는 addAll 메서드를 사용한다.\n만약 이미 저장되어있는 요소와 중복된 요소를 추가하려고 하는 경우, 이 메서드들은 false를 반환함으로써 추가에 실패했다는 것을 알린다.\nPerson클래스는 name, age를 멤버변수로 갖는다.\n위의 예제는 name, age가 같으면 같은 사람으로 인식하도록 작성하였다.\n하지만 실행결과를 보면 두 인스턴스의 name, age가 같음에도 불구하고 서로 다른것으로 인식하여 'david:10'이 두번 출력되었다.\nHashSet의 add메서드는 새로운 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 호출하기 때문에, equals()와 haseCode()를 목적에 맞게 오버라이딩 해야한다.\nPerson tmp = (Person) obj;\nPerson 클래스를 위와 같이 수정하고 다시 [예제 11-23]을 실행해보면 다음과 같은 실행결과가 출력된다.\n오버라이딩을 통해 작성된 hashCode()는 다음의 세 가지 조건을 만족시켜야 한다.\n실행중인 어플리케이션 내의 동일한 객체에 대해서 여러번 hashCode()를 호출해도 동일한 값을 반환해야 한다.\n하지만, 실행시마다 동일한 int값을 반환할 필요는 없다.\nequals 메서드를 이용한 비교에 의해 ture를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 반드시 같아야한다.\nequals 메서드를 호출했을 때 false를 반환하는 두 객체는 hasCode() 호출에 대해 같은  int 값을 반환하는 경우가 있어도 괜찮지만, 해싱을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int값을 반환하는 것이 좋다.\n두 객체에 대해 equals 메서드를 호출한 결과가 true이면, 두 객체의 해시코드는 반드시 같아야하지만,\n두 객체의 해시코드가 같다고 해서 equals 메서드의 호출결과가 반드시 true인 것은 아니다.\n이진검색트리 형태로 데이터를 저장하는 컬렉션 클래스이다.\n중복된 데이터의 저장을 허용하지 않으며,\n왼쪽 노드의 값 < 부모 노드의 값 < 오른쪽 노드의 값\n왼쪽 노드 - 부모 노드 - 오른쪽 노드\n순으로 읽어오면 오름차순으로 정렬된 순서를 얻을 수 있다.\nTreeSet은 이처럼 정렬된 상태를 유지하기 때문에 단일값 검색, 범위검색이 매우 빠르다.\n, 정렬순서는 문자의 코드값이 기준이 된다.\n공백 < 숫자 < 대문자 < 소문자\n컴퓨터는 알아서 값을 비교하지 못한다.\nTreeSet은 데이터를 정렬된 상태로 저장한다.\n저장하는 객체에 구현된 정렬방식에 따라 정렬하여 저장하게 되고,\n지정된 정렬방식에 떄라 정렬하여 저장한다.\nStudent s1 = (Student)o1;\nStudent s2 = (Student)o2;\nMap 인터페이스를 구현했으므로 Key, Value를 하나의 데이터로 저장한다.\n해싱기법을 사용하기 때문에, 많은 양의 데이터를 검색하는 데 뛰어난 성능을 보인다.\n해싱을 구현한 컬렉션 클래스는 HashSet, HashMap, HashTable이 있는데, 컬렉션 프레임웍이 도입되면서 HashTable이 HashMap으로 대체되었다.\nHashTable은 호환성을 위해 남겨두고 있는 것이기 때문에, HashMap을 사용할 것을 권장한다.\n추가적으로 Hashtable은 key, value로 null을 허용하지 않지만, HashMap은 null을 허용한다.\n과 같이 할 수 있다.\nHashMap은 key, value를 각각\n하기 때문에 어떠한 객체도 저장할 수 있다.\nkey는 주로 String을 대문자 또는 소문자로 통일해서 사용하곤 한다.\n는 컬렉션 내에서 유일해야 하고(저장된 value를 찾는데 사용되는 것이기 때문에),\n는 데이터의 중복을 허용한다.\n위와 같이 HashMap을 생성하고 데이터를 저장하면\n3개의 데이터 쌍을 저장했지만 실제로는 2개의 데이터 쌍만 저장된다.\n세번째로 저장한 \"aaa\" key는 이미 존재하기 때문에, 새로 추가되지 않고 기존의 value 값을 덮어썼다.\nMap에서 value는 중복을 허용하지만, key는 중복을 허용하지 않기 때문에 저장하려는 두 데이터 중에서 어느 쪽을 key로 할 것인지 잘 결정해야한다.\n, 해시함수를 이용해서 데이터를 해시테이블에 저장하고 검색하는 기법을 말한다.\n는 데이터가 저장되어 있는 곳을 알려주기 때문에, 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있다.\n배열과 링크드 리스트의 조합으로 되어있다.\n저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결된 링크드 리스트에 저장하게 된다.\n예를 들어, 병원에서 수많은 환자를 분류할 때 생년을 기준으로 같은 연대생끼리 같은 서랍에 분류할 수 있다.\n서랍은 해싱에서 사용되는 자료구조 중 배열의 각 요소를 의미하며, 배열의 각 요소에는 링크드리스트가 저장되어있어서 실제 저장한 데이터는 링크드 리스트에 담겨지게 된다.\nHashMap에 저장된 데이터를 찾는 과정\n검색하고자 하는 값의 키로 해시함수를 호출한다.\n해시함수의 계산결과인 해시코드를 이용해서, 해당 값이 저장되어있는 링크드리스트를 찾는다.\n링크드리스트에서 검색한 키와 일치하는 데이터를 찾는다.\n는 검색에 불리한 자료구조이기 때문에 크기가 커질수록 검색속도가 떨어진다.\n은 크기가 커져도 원하는 요소가 몇번째에 있는지만 알면 빠르게 원하는 값을 찾을 수 있다.\n배열의 n번째 요소의 주소 = 배열의 시작주소 + type의 size * n\n이진검색트리의 형태로 key, value 데이터를 저장한다.\n이진검색트리를 사용하기 때문에 검색과 정렬에 적합한 컬렉션 클래스이다.\n일반적으로 HashMap이 더 뛰어나지만, 범위검색이나 정렬이 필요한 경우 TreeMap을 사용한다.\nTreeMap은 key 값들에 대한 정렬이 이루어지기 때문이다.\nHashMap의 구버전인 Hashtable을 상속받아 구현한 것이다.\n보다 단순화된 컬렉션 클래스이다.\nHashtable(Object, Object), Properties(String, String)\n주로 어플리케이션의 환경설정과 관련된 속성을 저장하는데 사용한다.\n데이터를 파일로부터 읽고 쓰는 기능을 제공하기 때문에, 간단한 입출력은 고작 몇줄의 코드고 쉽게 해결이 가능하다.\n//Properties에 저장된 모든 데이터를 화면 또는 파일에 출력\nObject setProperty(String key, String value)\n단순히 Hashtable의 put메서드를 호출할 뿐이다.\n그리고 setProperty()는 기존에 같은 키로 저장된 값이 있는 경우 그 값을 Object 타입으로 반환하며, 그렇지 않을 때는 null을 반환한다.\nStirng getProperty(String key, String defaultValue)\nProperties에 저장된 값을 읽어오는 역할을 하는데, 읽어오려는 키가 존재하지 않으면 지정된 기본값을 반환한다.\nCollections는 컬렉션과 관련된 메서드를 제공한다.\nCollection은 인터페이스이고, Collections는 클래스이다.\n멀티스레드 프로그래밍에서는 하나의 객체를 여러 스레드가 공유하기 때문에, 데이터 일관성을 유지하기 위해 공유되는 객체에 대한 동기화가 필요하다.\n원래 Vector, Hashtable의 클래스들은 자체적으로 동기화 처리가 되어있는데, 멀티스레드 프로그래밍이 아닌 경우에는 불필요한 기능이 되어 오히려 성능을 떨어뜨리는 요인이 되었다.\n그래서 ArrayList, HashMap 컬렉션은 동기화를 자체적으로 처리하지 않고, 필요한 경우에만 java.util.collections 의 동기화 메서드를 이용해서 처리하도록 되어있다.\nCollections 클래스에는 다음과 같은 동기화 메서드를 제공하고 있으므로, 동기화가 필요할 때 해당하는 것을 골라서 사용하면 된다.\nstatic Collection syncronizedCollection(Collection c)\nstatic List syncronizedList(List l)\nstatic Set syncronizedSet(Set s)\nstatic Map syncronizedMap(Map m)\nstatic SortedSet syncronizedSortedSet(SortedSet s)\nstatic SotredMap syncronizedSortedMap(SotredMap m)\n컬렉션에 저장된 데이터를 보호하기 위해\n으로 만들어야 할 때 사용한다.\n주로 멀티스레드 프로그래밍에서 여러 스레드가 하나의 컬렉션을 공유하다보면 데이터가 손상될 수 있는데 이를 방지하기 위해 아래의 메서드를 사용한다.\nstatic Collection unmodifiableCollection(Collection c)\nstatic List unmodifiableList(List l)\nstatic Set unmodifiableSet(Set s)\nstatic Map unmodifiableMap(Map m)\nstatic SortedSet unmodifiableSortedSet(SortedSet s)\nstatic NavigableSet unmodifiableNavigableSet(Set s)\nstatic SotredMap unmodifiableSortedMap(SotredMap m)\nstatic NavigableMap unmodifiableNavigableMap(Map m)\n인스턴스를 new연산자가 아닌 메서드를 통해서만 생성할 수 있게 함으로써 생성할 수 있는 인스턴스의 개수를 제한하는 방법이다.\nstatic List singletonList(Object o)\nstatic Set singleton(Object o)\nstatic Map singletonMap(Object key, Object value)\n매개변수로 저장할 요소를 지정하면, 해당 요소를 저장하는 컬렉션을 반환한다.\n그리고 반환된 컬렉션은 변경할 수 없다.\n한 종류의 객체만 저장하는 컬렉션 만들기\n컬렉션에 모든 객체를 저장할 수 있다는 것은 장점이면서 단점이다.\n컬렉션에 지정된 종류의 객체만 저장할 수 있도록 제한하고 싶을 때는 아래의 메서드를 사용한다.\nstaic Collection checkedCollection (Collection c, Class type)\nstaic List checkedList(List list, Class type)\nstatic Set checkedSet(Set s, Class type)\nstatic Map checkedMap(Map m, Class keyType, Class valueType)\nCollections 클래스의 메서드들은 static 메서드이기 때문에,\nCollections.sort(computers) 이런식으로 바로 사용할 수 있다.\n1.14 컬렉션 클래스 정리  요약"
  },
  {
    "chapter": 11,
    "title": "Chapter 12 지네릭스, 열거형, 애너테이션",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter12.html",
    "content": "Chapter 12 지네릭스, 열거형, 애너테이션\nJDK1.8 선택이 아닌 필수\n다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크(compile-time type check)를 해주는 기능\n의도하지 않은 타입의 객체가 저장되는 것을 막아 잘못 형변환 되는 오류를 줄여준다.\n(타입체크와 형변환 생략 -> 코드 간결)\n클래스: 지네릭스 도입 이전에는 각 객체의 형을 체크해야 했음\n1.2 지네릭 클래스의 선언\n// 지네릭 타입 T를 선언\n// class Box {\n// void setItem(Object item) {\n// Object getItem() {\n// T 대신 실제 타입 지정\n// ERROR: String타입 이외의 타입은 지정불가\n// OK: String타입만 가능\n// String item = (String)b.getItem();\nString item = b.getItem();\n// OK: T는 Object로 간주된다.\n// WARN: unchecked or unsafe operation.\n: 타입 변수(type variable)\n가 아닌 다른 것도 사용가능하다.\n상황에 맞게 의미 있는 문자를 선택해서 사용하는 것이 좋다.\n기호만 다를 뿐 '임의의 참조형 타입'을 의미한다.\n클래스: 어떤 타입이든 한가지 타입을 정해서 넣을 수 있다.\n타입만 담을 수 있다.\n// 지네릭 타입을 String으로 지정\n: 지네릭 클래스, 'T의 Box' 또는 'T Box' 라고 읽는다.\n: 타입변수 또는 타입매개변수, T는 타입문자\n: 원시타입 (raw type)\n: 지네릭 타입 호출, 여기서\n은 매개변수화된 타입(parameterized type) 또는 대입된 타입\n에 서로 다른 타입을 대입하여 호출한 것일 뿐 동일한 클래스이며, 컴파일후에 모두 원시타입(\n)로 바뀌어 지네릭 타입이 제거된다.\n모든 객체에 동일하게 동작해야 하는 static멤버에는 타입변수 T를 사용할 수 없다.\nT는 인스턴스변수로 간주되기 때문이다.\nstatic에는 인스턴스변수를 참조할 수 없다.\n지네릭 타입의 배열을 (선언은 가능하지만) 생성하는 것은 불가능하다.\nnew연산자, instacneof연산자는 컴파일 시점에 타입T가 뭔지 정확하게 알아야 하기 때문에 T를 피연산자로 사용할 수 없다.\n/* 지네릭스는 인스턴스별로 다르게 동작하려고 만든 기능 */\n// OK: Apple객체만 저장가능\n// OK: Grape객체만 저장가능\n/* 타입변수는 static에는 사용불가 */\n(T t1, T t2)\n/* 지네릭타입배열 생성불가 */\n// OK: T타입의 배열을 위한 참조변수\n// ERROR: 지네릭 배열 생성 불가\n참고: 지네릭 배열을 꼭 생성해야 할 경우 방법\nnew연산자 대신 'Reflection API'의\n와 같이 동적으로 객체를 생성하는 메서드로 배열 생성\nObject배열을 생성해서 복사한 다음에\n1.3 지네릭 클래스의 객체 생성과 사용\n// ERROR: 참조변수와 생성자에 대입된 타입이 일치해야 한다.\n// 타입 상속관계: Apple이 Fruit의 자손일 경우\n// ERROR: 상속관계여도 일치된 타입이여야 한다.\n// 지네릭 클래스 상속관계: FruitBox\n// 추정가능한 타입 생략 가능 (JDK1.7부터)\n// 생성시 대입된 타입과 다른 타입의 객체 추가 불가\n// 타입 상속관계: Apple이 Fruit의 자손\n// ERROR: Fruit만 가능\n1.4 제한된 지네릭 클래스\n// Fruit의 자손만 타입으로 지정\n// OK: Apple은 Fruit의 자손\n// ERROR: Toy는 Fruit의 자손이 아님\n// 다형성: 매개변수의 타입 T도 Fruit과 그 자손타입이 가능해짐\n// (따라서, T에 Object를 대입하면 모든 종류의 객체를 저장할 수 있게 됨)\n// OK: Apple이 Fruit의 자손\n// OK: Grape가 Fruit의 자손\n// 특정 인터페이스를 구현해야 한다는 제약 (인터페이스도 implements가 아니라 extends)\n// Fruit의 자손이면서 Eatable 인터페이스도 구현해야 한다는 제약\n를 매개변수에 사용할 수 없다.\n지네릭스를 사용하지 않거나, 특정 타입을 지정해서 써야 한다.\n하지만, 특정타입을 지정하면 여러가지 타입을 받을 수가 없다.\n(Fruit f: box.getList()) tmp += f +\n특정타입을 고정하면 여러가지 타입의 매개변수를 갖도록 오버로딩해야 한다.\n하지만, 지네릭 타입이 다른 것만으로는 오버로딩이 성립되지 않는다.\n이때 사용하기 위해 고안된 것이 '\n와일드카드는 어떠한 타입도 될 수 있다.\n로 상한과 하한을 제한 할 수 있다.\n: 와일드카드의 상한 제한 (\n와 그 자손들만 가능)\n: 와일드카드의 하한 제한 (\n와 그 조상들만 가능)\n: 제한없음 (모든 타입 가능),\n지네릭 클래스와 달리 와일드 카드에는\n을 사용할 수 없다.\n의 매개변수로 모든 타입의\n가 올 수 있지만,\n타입만을 받을 수 있다.\n을 제한하고 있기 때문에 컴파일에 문제가 생기지 않는다.\n의 자손이라는 것을 알기 때문\n메서드의 선언부에 지네릭 타입이 선언된 메서드\n와 지네릭 메서드의 타입매개변수\n지네릭 메서드는 지네릭 클래스가 아닌 클래스에도 정의 가능\n멤버에는 타입 매개변수를 사용할 수 없지만,\n메서드에 선언된 타입은 지역변수와 같은 느낌\n// static Juice makeJuice(FruitBox\n// 타입 생략가능 (컴파일러가 추정가능)\n: 지네릭 메서드 호출시 대입된 타입 생략이 불가능한 경우에는 참조변수나 클래스 이름을 생략할 수 없다.\n// ERROR: 클래스 이름 생략불가\n매개변수의 타입이 복잡할 때 간략화\n// public static void printAll(ArrayList\n(Unit u: list) { System.out.println(u); }\n복잡하게 선언된 지네릭 메서드 예제\n을 구현한 클래스여야 한다.\n또는 그 조상 타입을 비교하는\n인터페이스를 구현한 것이어야 한다.\n1.7 지네릭 타입의 형변환\n지네릭타입 <-> 원시타입: OK\n// OK: Box -> Box\n지네릭타입 <-> 지네릭타입: ERROR\n와일드카드 지네릭타입 <-> 지네릭타입: OK\n// 매개변수의 다형성 제공\n// 미확인 타입으로 형변환 경고\n를 줄여서 쓴 것\n로 형변환이 가능하기 때문\n: 형변환 가능 (경고)\n와일드카드 지네릭 타입 <-> 와일드카드 지네릭타입: OK\n// 미확정 타입으로 형변환 경고\n// void add(T t) {\n2단계: 지네릭 타입을 제거한 후에 타입이 일치하지 않으면 형변환 추가\n// T get(int i) {\n// for(Fruit f: box.getList()) tmp += f + \" \";\nIterator it = box.getList().iterator();\ntmp += (Fruit)it.next() +\nJDK 1.5 새로 추가.\nC언어의 열거형보다 향상된 기능 : 값 뿐만 아니라 타입까지 관리 (논리적인 오류를 줄임)\npublic class Card {\nenum Kind { CLOVER, HEART, DIAMOND, SPADE }\nenum Value {TWO, THREE, FOUR }\nfinal Kind kind = Kind.CLOVER;\nfinal Value value = Value.TWO;\n상수 사용할 경우, 상수를 사용하면 해당 상수를 참조하는 모든 소스를 다시 컴파일 해야함\n열거형 상수를 사용하면 기존 소스를 다시 컴파일 하지 않아도 된다.\n2.2 열거형의 정의와 사용\n// enum 열거형 이름 { 상수명1, 상수명2, ...}\nenum Direction { EAST, WEST, SOUTH, NORTH }\n사용 : 열거형 이름.상수명\n\"compareTo()\" 사용 (\">\", \"<\" 사용 불가) : 왼쪽이 크면 양수, 오른쪽이 크면 음수\nDirection direction = Direction.EAST;\n( direction == Direction.EAST )\n//else if (direction > Direction.WEST)\nswitch 조건식 : 열거형 사용\ncase문은 열거형 이름은 적지 않고 상수이름만 적어야 함\ncase Direction.EAST: // Error!\n모든 열거형의 조상 - java.lang.Enum\n다음과 같은 메서드가 정의되어 있음\ngetDeclaringClass() // 열거형의 클래스 객체를 반환\nString name() // 열거형 상수의 이름을 문자열로 반환\nint ordinal() // 열거형 상수가 정의된 순서를 반환 (0부터 시작)\nenumType, String name) // 지정된 열거형에서 name 과 일치하는 열거형 상수를 반환\nDirection direction = Enum.ValueOf(Direction.class,\nString name = direction.name();\n열거형에 모든 상수를 출력하려면..\nDirection[] directionArr = Direction.values();\n(Direction direction : directionArr) {\n2.3 열거형에 멤버 추가하기\n열거형 상수에 지정한 값을 넣기 -> 인스턴스 변수와 생성자를 새로 추가해주어야 한다.\n// 인스턴스 변수에 반드시 final 을 붙여야한다는 제약은 없지만,\n// value는 열거형 상수값을 저장하기 위한 것이므로 final을 붙였음.\n열거형에 추상 메서드 추가하기\n* 거리에 따른 요금 계산하 추상 메서드\n// protected로 해야 각 열거형 상수에서 접근 가능\n기본 Enum 과 유사한 MyEnum 을 만들어 보는 예제\n// 객체를 생성할 때마다 1씩 증가시킨다.\n타입 T에 ordinal 사용불가\n// compareTo 에러 수정\n타입 T에 ordinal 사용 가능\n// 타입 T가 MyEnum\n의 자손이어야 한다는 의미\n// T가 MyEnum의 자손이므로 t.ordinal() 접근이 가능해짐\n// ordinal 값 접근 가능\nMyTransportation t1 = MyTransportation.BUS;\nMyTransportation t2 = MyTransportation.TRAIN;\n자바를 개발하는 사람들은 소스코드에 대한 문서를 따로 만들기보다는 문서를 하나의 파일로 관리 하는 것이 낫다고 생각하였다.\n* 자바 API문서 만들기 예제 소스\n소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함 시킨 것\n주석(comment)처럼 프로그래밍 언어에 영향을 미치지 않으면서 다른 프로그램에게 유용한 정보 제공 가능\n// 이 메서드가 테스트 대상임을 테스트 프로그램에게 알린다.\n와 같이 JDK가 기본적으로 제공해주는 것 : 표준 애너테이션\n다른 프로그램에서 제공하는 것들이 있음\n컴파일러에게 오버라이딩하는 매서드라는 것을 알린다\n앞으로 사용하지 않을 것으로 권장하는 대상에 붙인다\n컴파일러의 특정 경고메세지가 나타나지 않게 해준다\n지네릭스 타입의 가변인자에 사용한다 (JDK1.7)\n함수형 인터페이스라는 것을 알린다 (JDK1.8)\nnative 메서드에서 참조되는 상수 앞에 붙인다 (JDK1.8)\n애너테이션 적용가능한 대상을 지정하는데 사용한다\n애니테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다\n애니테이션 자손 클래스에 상속되도록 한다\n애너테이션이 유지되는 범위를 지정하는데 사용한다\n애너테이션을 반복해서 적용할 수 있게 한다 (JDK1.8)\n애너테이션을 붙여주면, 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고, 없으면 에러 메시지를 출력해준다\nDeprecated 애너테이션 : JDK1.1부터 추가된 Calendar 클래스의 get 을 사용하도록 유도\nSuppressWarnings : deprecation, unchecked, unused 경고 메세지가 나타나지 않게 해준다\n메타 애너테이션은 '애너테이션을 위한 애너테이션', 즉 애너테이션에 붙이는 애너테이션으로 애너테이션의 적용 대상(target)이나 유지기간(retention)등을 지정하는데 사용된다\n({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\n[코드: SuppressWarnings 애너테이션 정의 예제]\n: 적용가능한 대상을 지정하는데 사용된다.\n타입(클래스, 인터페이스, enum, 애너테이션)\n타입에 사용되는 모든 곳(JDK1.8)\n소스 파일에만 존재, 클래스 파일에는 존재하지 않음\n클래스 파일에 존재, 실행시에 사용 불가.\n클래스 파일 존재, 실행시에 사용 가능\n: javadoc으로 작성한 문서에 포함되도록 한다\n: 자손 클래스에 상속되도록 한다.\n조상 클래스에 붙이면, 자손 클래스도 애너테이션이 붙는 것과 같이 인식된다\n: 보통 하나의 대상에 한종류의 애너테이션을 붙일 수 있음.\n여러번 붙일 수 있도록 하는 메타 애너테이션\n: 네이티브 메서드에 의해 참조되는 '상수필드(constanct field)'에 붙이는 애너테이션\n3.4 애너테이션 타입 정의하기\n// 애너테이션의 요소를 선언한다\n애너테이션 요소는 반환값이 있음\n매개변수는 없는 추상 메서드의 형태를 가짐 : 상속을 통해 구현하지 않아도 됨\n애너테이션이 적용될 때는 요소들의 값을 빠짐없이 지정해주어야 한다\n요소의 이름도 같이 적어주므로, 순서는 상관없다\n// enum TestType {FIRST, FINAL}\n// 자신이 아닌 다른 애너테이션()을 토함시킬수 있다\n요소의 타입으로 기본형은 String, enum, 애너테이션, Class만 허용된다\n() 안에 매개변수를 선언할 수 없다\n예외를 선언할 수 없다\n요소를 타입 매개변수로 정의할 수 없다\nstatic final int id = 100;\n// 에러, 매개변수를 선언할 수 없음\n// 에러, 예외를 선언할 수 없음\n// 에러, 요소의 타입에 타입매개변수 사용 불가\nScheduled annotation at Springframework\n\"* * 1 * * ?\"\n// 매일 오전 1시에 실행한다.\n// 1000 * 60 * 60, 즉 1시간마다 실행한다."
  },
  {
    "chapter": 12,
    "title": "Chapter 13 쓰레드(Thread)",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter13.html",
    "content": "프로세스(process)란 실행 중인 프로그램(program)\n프로세스는 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있다.\n실제로 작업을 수행하는 것이 바로 쓰레드(thread)이다.\n프로세스(공장), 쓰레드(일꾼) : 싱글 쓰레드\n프로세스(공장), 쓰레드들(일꾼 들) : 멀티 쓰레드\n쓰레드를 가벼운 프로세스, 즉 경량 프로세스(LWP,light-weight process)라고 부르기도 한다.\nCPU의 사용률을 향상 시킨다.\n자원을 보다 효율적으로 사용할 수 있다.\n사용자에 대한 응답성이 향상된다.\n작업이 분리되어 코드가 간결해진다.\n멀티 쓰레드 고려할 사항\n여러 쓰레드가 같은 프로세스 내에서 자원을 공유하면서 작업을 하기 때문에\n동기화(synchronization), 교착상태(deadlock) 같은 문제들을 고려해서 프로그래밍 해야 한다.\nThread 클래스를 상속받는 방법\nRunnable 인터페이스를 구현하는 방법\n일반적으로 Runnable 인터페이스를 구현하는 방식을 사용함\n재사용성(reusability)를 높이고 코드의 일관성(consistency)를 유지할 수 있다.\n// Thread 클래스 메소드 직접 호출 가능\n// Runnable을 구현하면 Thread클래스의 currentThread()를 호출하여\n// 쓰레드에 대한 참조를 얻어와서 호출 해야 함\n// 쓰레드 t1을 실행시킨다.\n// 쓰레드 t2를 실행시킨다.\nstart()가 호출 되었다고 해서 바로 실행되는 것이 아니라, 일단 실행 대기 상태에 있다가 자신의 차례가 되어야 실행상태가 된다.\n한가지 더 주의할 사항\n하나의 쓰레드에 대해 start()가 한 번만 호출될 수 있다\n두 번 실행시 IllegalThreadStateException이 발생한다\n쓰레드를 실행 시킬 때 run()이 아닌 start()를 호출하는 것에 대한 다소 의문이 들었을 것이다.\nmain 메서드에서 run()을 호출하는 경우의 call stack\nmain 매서드에서 start()를 호출하는 경우\nmain 메서드에서 run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메서드를 호출하는 것일 뿐이다.\n실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.\n싱글 쓰레드와 멀티 쓰레드의 차이 (싱글코어)\n하나의 쓰레드로 두개의 작업을 수행하는 경우\nA 작업       B 작업\n두개의 쓰레드로 두개의 작업을 수행하는 경우\n싱글코어에서 단순히 CPU만을 사용하는 계산 작업이라면 오히려 멀티쓰레드보다 싱글 쓰레드로 프로그래밍 하는 것이 더 효율적이다.\n이유: Context switching : 쓰레드간 전환 작업 (현재의 작업 상태를 저장하는 과정)\n싱글 코어로 두개의 쓰레드를 실행 및 처리하는 경우 : 병행(concurrent)\n멀티 코어로 두개의 쓰레드를 실행 및 처리하는 경우 : 병렬(parallel)\n두 쓰레드가 서로 다른 자원을 사용하는 작업의 경우에는 싱글쓰레드 프로세스보다 멀티 쓰레드 프로세스가 더 효율적이다.\n예를 들면, 사용자로부터 데이터를 입력받는 작업, 네트워크로 파일을 주고받는 작업, 프린터로 파일을 출력하는 작업과같이 외부기기와의 입출력이 필요로 하는 경우가 이에 해당된다.\n쓰레드는 우선순위(priority)에 따라서 실행 시간이 달라진다.\n// Thread 우선순위를 지정한 값으로 변경한다.\n// Thread의 우선순위를 반환한다.\n// 보통 우선 순위\n싱글코어에서는 우선 순위의 영향을 받음\n멀티코어에서는 쓰레드의 우선순위를 더 주면 더 많은 실행 시간과 실행 기회를 갖는 것을 보장하지 못한다.\nOS의 스케쥴링 정책과 JVM의 구현에 따라 다름\n작업에 우선 순위를 두어\n에 저장해놓고 우선순위가 높은 작업이 먼저 처리도도록 하는 것이 나을 수 있다.\n쓰레드 그룹은 보안상의 이유로 도입된 개념으로, 자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹은 변경할 수 있지만 다른 쓰레드 그룹의 쓰레드를 변경할 수 없다.\nThread(ThreadGroup group, String name);\nThread(ThreadGroup group, Runnable target);\nThread(ThreadGroup group, Runnable target, String name);\nThread(ThreadGroup group, Runnable target ,String name,\njava application 을 실행하면 JVM은 main과 system이라는 쓰레드 그룹을 만든다.\nmain method 를 수행하는 main 이라는 쓰레드는 main 쓰레드 그룹에 속함\n카비지컬렉션을 수행하는 Finalizer 쓰레드는 system 쓰레드에 속함.\n데몬 쓰레드 : 다른 일반 쓰레드(데몬 쓰레드가 아닌 쓰레드)의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.\n데몬 쓰레드는 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료된다\n이점을 제외하고는 일반 쓰레드와 차이가 없다.\n가비지컬렉터, 워드프로세서의 자동저장, 화면 자동 갱신\n데몬 쓰레드는 무한 루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정 조건이 만족되면 작업이 수행되고 다시 대기하도록 작성한다.\n// 쓰레드가 데몬 쓰레드인지 확인한다.\n// 쓰레드를 데몬 쓰레드로 또는 사용자 쓰레드로 변경한다.\n// Daemon thread example\n// **이 부분이 없으면 종료되지 않는다.\n// **데몬쓰레드 실행을 위한 무한루프 실행 및 특정 조건 일때 실행**\n// TODO Auto-generated catch block\nThread의 상태는 아래와 같다.\n쓰레드가 생성되고 아직 start()가 호출 되지 않은 상태\n실행 중 또는 실행 가능한 상태\n동기화 블럭에 의해서 일시 정지된 상태 (lock이 풀릴 때까지 기다리는 상태)\n쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은 (unrunnable) 일시정지 상태.\nTIMED_WAITING은 일시정지 시간이 지정된 경우를 의미\n쓰레드의 작업이 종료된 상태\nThread의 상태는 getState() 메서드를 호출해서 확인이 가능함 (JDK1.5 추가됨)\n[참고] resume(), stop(), suspend()는 쓰레드를 교착상태(deadlock)로 만들기 쉽기 때문에 deprecated 되었다.\n// sleep(): 작업 흐름 대기시간 설정한다.\n// 5초동안 대기시간 갖은 후에 다음 문자의 실행흐름을 이어 나간다.\nth1 종료 이 가장 늦게 종료 될 것으로 예상\nth1 종료 -> th2 종료 -> main 종료\n이유 : sleep()이 항상 실행 중인 쓰레드에 대해 작동하기 때문에 실제 영향을 받는 것은 main 메서드 이기 때문\n그래서 sleep()은 static 으로 선언되어 있으며, 참조 변수를 이용해서 실행하는 것보다\n진행 중인 쓰레드의 작업이 끝나기 전에 취소시켜야 할 때가 있는 경우 사용\n예를 들어 큰 파일을 다운로드 받을 때 시간이 너무 오래 걸리면 중간에 다운르도를 포기하고 취소할 수 있어야 한다.\ninterrupt()는 쓰레드에게 작업을 멈추라고 요청한다.\n실제 동작 : 그저 쓰레드의 interrupted 상태 (인스턴스 변수)를 바꾸는 것일 뿐이다.\n// 쓰레드의 interrupted 상태를 false에서 true로 변경\n// 쓰레드의 interrupted 상태를 반환\n// 현재 쓰레드의 interrupted 상태를 알려주고, false로 초기화\nString input = JOptionPane.showInputDialog(\n\"input value is \"\ninput value is TTT\n이유: Thread.sleep(1000) 에서 InterruptedException 발생\nsleep() 에 의해 쓰레드가 멈춰있을 때, interrupt()를 호출하면 InterruptedException 발생되고 interrupted 상태는 false로 자동 초기화됨\nsuspend(): sleep() 처럼 쓰레드를 멈추게 한다.\nresume():  suspend() 에 의해 정지된 쓰레드는 resume()을 호출해야 다시 실행 대기 상태가 된다.\nstop(): 호출되는 즉시 쓰레드가 종료된다.\n쓰레드의 실행을 제어하는 가장 손쉬운 방법이지만, suspend()와 stop()이 교착상태(deadlock)을 일으키기 쉽게 작성되어 있으므로 사용이 권장되지는 않는다.\nyeild() : 다른 쓰레드에게 양보한다.\n예를 들어 스케쥴러에 의해 1초 실행 시간을 할당받는 쓰레드가 0.5초의 시간동안 작업한 상태에서  yeild를 호출되면, 나머지 0.5초는 포기하고 다시 실행 대기 상태가 된다.\nyeild()와 interrupt()를 적절히 사용하면 프로그램의 응답성을 높이고 보다 효율적인 실행이 가능하게 할 수 있다.\n참고 예제는 교재 p760761 참고\njoin() : 쓰레드 자신이 하던 작업을 멈추고 다른 쓰레드가 지정된 시간 동안 작업을 수행하도록 할 때 join()을 사용한다.\njoin()도 sleep()처럼 interrupt()에 의해 대기상태에서 벗어날 수 있다.\nsleep()과 다른 점은 join()은 특정 쓰레드에 대해 동작하므로 static 메서드가 아니라는 점이다.\n// main쓰레드가 t1의 작업이 끝날때까지 기다린다.\n// main쓰레드가 t2의 작업이 끝날때까지 기다린다.\n+ (System.currentTimeMillis() - startTime));\n//가비지 컬렉션역할의 스레드 생성\n//GargabeCollection 스레드를 데몬 스레드로 설정\n//가비지 컬렉션 스레드 시작\n//필요한 메모리의 크기를 난수를 사용해서 설정한다.\n//즉, 컴퓨터에서 동작하는 프로그램에서 사용하려는 메모리의 크기를 흉내낸 것이다.\n// 필요한 메모리가 사용할 수 있는 양보다 크거나 전체 메모리의 60이상을\n// 사용했을 경우 gc를 깨운다.\ngc.freeMemory() < gc.totalMemory() *\n//잠자고 있는 데몬 스레드를 깨운다.\n//사용 중인 메모리 크기가 프로그램에서 사용하는 메모리 크기 만큼 증가한다.\n//사용중인 메모리 크기를 출력\n//메모리의 최대 크기, 즉 메모리 크기가 1000 이상이 될 수 없슴\n//사용 중인 메모리 크기\n//10초를 자고 일어나서 가비지 컬렉션을 수행한다.\n//gc.interrupt();에 의해서 스레드가 잠에서 깰 때 이 예외가 발생한다.\n//10초 동안 자고 일어나서 garbage collection을 수행한다.\n//가비지 컬렉션을 수행한 후의 메모리 크기를 출력한다.\n//가비지 컬렉션을 수행하는 메소드\n//사용중인 메모리 크기를 줄인다.\n//사용중인 메모리 값이 마이너스가 되지 않도록한다.\n//전체 메모리 크기를 알려주는 메소드\n//사용가능한 메모리 크기를 알려주는 메소드\n위의 스레드 프로그램은 메모리의 최대 크기가 1000으로 설정되었기 때문에, 어떠한 경우에도 출력된 메모리의 크기가 1000을 넘을 수 없다.\n그러나, 반복해서 실행하다 보면 사용 중인 메모리의 크기가 1000을 넘어가는 현상을 발견할 수 있다.\nmain 쓰레드가 interrupt() 호출 후에 자신의 작업을 진행하기 때문\n해결책 : join() 메서드로 main 쓰레드는 잠시 대기\n// 깨우고 나서 일정한 시간을 기다려서\n// 가비지 컬렉션 작업을 할 수 있도록 작업 시간을 보장해 준다.\n//가비지 컬렉션이 0.1초 동안 일을 할 동안 기다린다.\n(InterruptedException e) { }\n멀티 쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유하게 되므로 쓰레드의 동기화 개념이 필요하게 되었다.\n(참고: 싱글 쓰레드 프로세스의 경우 프로세스 내에서 단 하나의 스레드만 작업하기 때문에 프로세스의 자원을 가지고 작업하는데 별 문제가 없음)\n임계영역(Critical Section)과 잠금(락, lock)\n한 쓰레드가 특정 작업을 마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 함\n공유 데이터를 사용하는 코드 영역을 임계영역으로 지정해놓고, 공유 데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있도록 한다.\n한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것\n자바에서는 synchronized 블럭을 이용해서 동기화를 지원\nJDK1.5부터는 java.util.concurrent.locks와 java.util.concurrent.atomic 패키지를 통해서 다양한 방식으로 동기화를 구현할 수 있도록 지원함\n9.1 synchronized를 이용한 동기화\nsynchronized를 이용한 동기화 방법\n가능하면 메서드에 synchronized를 사용하는 메서드 단위의 동기화를 권장\n특정한 객체에 lock을 걸고자 할 때\n메서드에 lock을 걸고자할 때\n//**balance에 synchronized 를 위한 private 멤버 변수로 정의**\n// **동기화 적용 (메서드 단위의 동기화를 추천한다.\n/* 객체에 lock을 걸 경우\n여기에 소스 코드를 집어 넣어도 된다.\n// 100, 200, 300 중의 한 값을 임의로 선택해서 출금(withDraw)\n쓰레드를 동기화할 때 동기화의 효율을 높이기 위해 wait()와 notify()를 함께 사용할 수 있다.\n한 쓰레드가 객체에 lock을 걸고 어떤 조건이 만족될 때까지 기다려야 하는 경우, 이 쓰레드를 그대로 놔두면 이 객체를 사용하려는 다른 쓰레드들은 lock이 풀릴 때까지 같이 기다려야 하는 상황이 발생한다.\n이러한 비효율을 개선하기 위해서 wait()와 notify()를 사용한다.\n// 쓰레드가 락을 반납하고 대기실(waiting pool)에서 통지를 기다린다.\n// 작업을 중단했던 쓰레드가 다시 락을 얻어서 작업을 진행하게 된다.\n// wait()에 의해 lock을 반납했다가,\n// 다시 lock을 얻어서 임계 영역에 들어오는 것을 **재진입(reentrance)**라고 한다.\n동기화 블록(synchronized 블록) 내에서만 사용할 수 있다.\n보다 효율적인 동기화를 가능하게 한다.\nnotify()가 호출되면, 해당 객체의 대기실에 있던 모든 쓰레드 중에서 임의의 쓰레드만 통지를 받는다.\nnotifyAll()은 기다리고 있는 모든 쓰레드에게 통보를 하지만, 그래도 lock을 얻지 못하면 다시 lock을 기다리게 된다.\n기아 상태와 경쟁 상태\n지독히 운이 없는 Thread는 계속 통지를 받지 못하고 오랫동안 기다리게 되는데 이것을 기아(starvation) 현상이라고 한다.\n이 현상을 막으려면 notify() 대신 notifyAll()을 사용해야 한다.\n일단 모든 쓰레드에게 통지를 하면, 쓰레드가 waiting pool에 들어가더라도 쓰레드는 결국 lock을 얻어서 작업을 진행할 수 있기 때문이다.\nnofifyAll()로 쓰레드의 기아현상을 막았지만 여러 쓰레드들이 불가피하게 lock을 얻기 위해 경쟁을 하게 된다.\n이처럼 여러 쓰레드가 lock을 얻기위해 서로 경쟁하는 것을 경쟁상태('race condition')이라고 한다.\n아래 Lock과 condition을 이용하면 wait()와 notify()로는 불가능한 선별적인 통지가 가능해진다.\n9.3 Lock과 Condition을 이용한 동기화\n동기화할 수 있는 방법은 synchronized 블럭 외에도 'java.util.concurrent.locks' 패키지가 제공하는 lock 클래스들을 이용하는 방법이 있다.\nReentrantLock은 가장 일반적인 lock이다.\n'reentrant(재진입할 수 있는)'이라는 단어가 앞에 붙은 이유는 우리가 앞서 wait()  notify()에서 배운 것처럼, 특정 조건에서 lock을 풀고 나중에 다시 lock을 얻고 임계영역으로 들어와서 이후의 작업을 수행할 수 있기 때문이다.\nStampedLock은 lock을 걸거나 해지할 때 '스탭프(long타입의 정수값)'를 사용하며, 읽기와 쓰기를 위한 lock외에 낙관적 읽기 lock이 추가된 것이다.\n읽기 lock이 걸려있으면, 쓰기 lock을 얻기 위해서는 읽기 lock이 푸릴ㄹ 때까지 기다려야 하는데 비해 '낙관적 읽기 lock'은 쓰기 lock에 의해 바로 풀린다.\n그래서 낙관적 ㅇ릭기에 실패하면 읽기 lock을 얻어서 다시 읽어와야 한다.\n무조건 읽기 lock을 걸지 않고, 쓰기와 읽기가 충돌할 때만 쓰기가 끝난 후 읽기 lock을 거는 것이다.\n아직 lock 클래스들에 대해 자세히 배우지 않았지만, 낙관적 읽기 lock을 어떻게 사용하는 지 감을 잡을 수 있을 것이다.\nReentrantLock은 다음과 같이 두 개의 생성자를 가지고 있다.\n생성자의 매개변수를 true로 주면, lock이 풀렸을 때 가장 오래 기다린 쓰레드가 lock을 획득할 수 있게, 즉 공정하게 처리한다.\n자동적으로 lock의 잠금과 해제가 관리되는 synchronized블럭과 달리, ReentrantLock과 같은 lock클래스들은 수종으로 lock을 잠금고 해제해야 한다.\n그대로 lock을 잠금고 푸는 것은 간단하다.\n그저 메서드를 호출하기만 하면 될 뿐이다.\nlock을 걸고 나서 푸는 것을 잊어버리는 실수를 하지 않도록 주의를 기울여야 한다.\n// 임계영역 , 이렇게 하면 중간에 예외가 발생하면 lock이 안풀린다.\n// 임계영역, 이렇게 하면 임계영역에서 예외나 에러가 발생해도 finally에서 unlock 시켜서 안전\n이외에도 tryLock()ㅇ;라는 메서드가 있는데, 이 메서드는 lock()과는 달리, 다른 쓰레드에 의해 lock이 걸려있으면 lock을 얻으려고 기다리지 않는다.\n또는 지정된 시간만큼만 기다린다.\nlock을 얻으면 true를 반환하고 얻지 못하면 false를 반환한다.\nlock()은 lock을 얻을 때까지 쓰레드를 블락시키므로 쓰레드의 응답성이 나빠질 수 있다.\n응답성이 중요한 경우 tryLock()을 이용해서 지정된 시간동안 lock을 얻지 못하면 다시 작업을 시도할 것인지 포기할 것인지를 사용자가 결정할 수 있게 하는 것이 좋다.\n앞서 wait()  notify() 예제에 요리사 쓰레드와 손님 쓰레드로 구분해서 통지하지 못한다는 단점이 있다는 것을 기억할 것이다.\nCondition은 이 문제를 해결하기 위한 것이다.\nwait()  notify()로 쓰레드의 종류를 구분하지 않고, 공유 객체의 waiting pool 에 같이 몰아넣는 대신, 손님 쓰레드를 위한 Condition과 요리사 쓰레드를 위한 Condition을 만들어서 각각의 waiting pool에서 따로 기다리도록 하면 문제는 해결된다.\n말로 설명하는 것보다 직접 코드를 봅시다\nCondition forCook = lock.newCondition();\nCondition forCust = lock.newCondition();\n(dishes.size() >= MAX_FOOD) {\nString name = Thread.currentThread().getName();\nCustomer (Table table, String food){\n\" ate a \"\n싱글 코어 프로세서가 장착된 컴퓨터에서는 예제 13-16이 아무런 문제없이 실해오딜 것이다.\n그러나 요즘에 대부분 멀티 코어 프로세서가 장착된 컴퓨터를 사용하기 때문에 이 예제에서 문제가 발생한 가능성이 있다.\n코에는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다.\n다시 같은 값을 읽어올 때는 먼터 캐시에 있는지 확인하고 없을 때만 메모리에서 읽어온다.\n그러다보니 도중에 메모리에 저장된 변수의 값이 변경되었는데도 캐시에 저장된 값이 갱신되지 않아서 메모리에 저장된 갑싱 다른 경우가 발생한다.\n그래서 변수 stopped의 값이 바뀌었는데도 쓰레드가 멈추지 않고 계속 실행되는 것이다.\n변수에 volatile을 붙이는 대신에 synchronized 블럭을 사용해도 같은 효과를 얻을 수 있다.\n쓰레드가 synchronized블럭으로 들어갈 때와 나올 때 캐시와 메모리간의 동기화가 이루어지기 때문에 값의 불일치가 해소되기 때문이다.\n아.. Thread-safe 하다는게 이거구나.. ㅋㅋㅋㅋ\nvolatile로 long과 double을 원자화합니다.\nlong과 double은 한 개 이상의 4바이트(=32bit)단위로 처리하기 때문에 int 와 int보다 작은 타입은 한번에 쓰는 게 가능합니다.\n하지만 long, double은 여러 개의 4바이트 블록을 쓰기 때문에 여러 쓰레드가 하나의 변수의 블록을 접근할 수 있다.\n그래서 long, double 변수에 volatile을 붙이면 Thread-safe 해집니다!\n9.5 fork  join 프레임웍\n10년 전까지만 해도 CPU 속도는 매년 거의 2배씩 빠르게 향상되어왔다.\n그러나 이제 그 한계에 도달하여 속도보다는 코어의 개수를 늘려서 CPU의 성능을 향상시키는 방향으로 발전해가고 있다.\n이러한 하드웨어의 변화에 발맞춰 프로그래밍도 멀티 코어를 잘 활용할 수 있는 멀티쓰레드 프로그래밍이 점점 더 중요해지고 있다.지금까지 배워서 잘 알겠지만 멀티쓰레드 프로그래밍이 그리 쉽지는 않다.\n그래서 JDK1.7부터 fork  join 프레임웍이 추가되었고, 이 프레임웍은 하나의 작업을 작은 단위로 나눠서 여러 쓰레드가 동시에 처리하는 것을 쉽게 만들어준다.\n먼저 수행할 작업에 따라 RecursiveAction과 RecursiveTask, 두 클래스 중에 하나를 상속받아 구현해야 한다.\n// 반환값이 없는 작업을 구현할 때 사용\n// 반환값이 있는 작업을 구현할 때 사용\n두 클래스 모두 compute() 라는 추상 메서드를 가지고 있는데, 우리는 상속을 통해 이 추상 메서드를 구현하기만 하면 되낟.\n에를들어 1부터 n까지의 합을 계산해서 결과를 돌려주는 작업을 구현하려면 다음과 같이 한다.\nclass SumTask extends RecursiveTask\nSumTask(long from, long to){\nLong result = pool.invoke(task);\ncompute()를 구현하 ㄹ때는 수행할 작업 외에도 작업을 어떻게 나눌 것인가에 대해서도 알려줘야 한다.\nsize = to - from;\n이렇게 작업을 나눠서 할당하는 거는 Divide  Conquare 같다.\n18 을 나누면 14 58로 나뉘고 다시 14는 12 34로 나뉜다.\n다른 쓰레드의 작업을 훔쳐오기 (work stealing)\n작업 훔쳐오기는 모두 쓰레드풀에 의해 자동적으로 이루어진다.\n큐가 비어있는 쓰레드는 일이 있는 쓰레드의 일을 자동적으로 가져옵니다.\nfork와 join은 더이상 작업을 나눌 수 없을 때까지 나눈다.\n나뉘진 작업은 각 쓰레드가 골고루 나눠서 처리하고 작업의 결과는 oin을 호출해서 얻을 수 있다.\nfork() // 해당 작업을 쓰레드 풀의 작업 큐에 넣는다.\njoin() // 해당 작업의 수행이 끝날 때까지 기다렸다가 수행이 끝나면 그 결과를 반환한다.\n+ (System.currentTimeMillis() - start));\n\"sum of dd = d/n\"\n, from, to, result);\ni = from ;  i<= to;i++){\n.from; i<= to ; i++)"
  },
  {
    "chapter": 13,
    "title": "Chapter 14 람다와 스트림",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter14.html",
    "content": "Chapter 14 람다와 스트림\n람다식은 메서드를 하나의 식(expression)으로 표현한 것.\n- 객체 지향 언어보다는 함수 지향 언어에 가깝다.\n- 함수를 간략하면서도 명확한 식으로 표현할 수 있도록 해준다.\n- 메서드를 람다식으로 표현하면 메서드의 이름 및 반환 값이 없어지므로 익명 함수 라고도 한다.\n- 람다식의 형태는 매개 변수를 가진 코드 블록이지만 런타임 시에는 익명 구현 객체를 생성한다.\n(타입 매개변수) -> { 실행문; ... }\npublic static void main(String[] args)\nExFunctionInterface test = new ExFunctionInterface() {\npublic void method() {\nExFunctionInterface test = () -> System.out.println(\"test\");\n반환 값이 있는 메서드의 경우 return 대신 expression 으로 대신할 수 있다.\n(expression인 경우 ; 를 붙이지 않는다.)\n람다식에 선언된 매개변수 타입은 추론이 가능한 경우 생략 가능(대부분 생략가능)\n매개 변수가 하나인 경우 ()를 생략할 수 있다.\n{} 안 문장이 하나인 경우 생략할 수 있다.\n1.3 함수형 인터페이스(Functional Interface)\n함수형 인터페이스는 람다식을 다루기 위한 인터페이로 하나의 추상 메서드만 정의되어 있어야 한다.\n단, static 메서드와 default 메서드의 개수에는 제약이 없다.\n함수형 인터페이스 타입의 매개변수 및 반환 타입이 함수형 인터페이스 타입이라면 람다식을 참조하는 참조변수를 매개변수로 지정하고 람다식을\n가리키는 참조변수를 반환하거나 또는 람다식 자체를 반환할 수 있다.\n람다식은 Object 타입으로 형변환 할 수 없으며, 오직 함수형 인터페이스로만 형변환이 가능하다.\n람다식 내에서 참조하는 지역변수는 final이 붙어 있지 않아도 상수로 간주되며, 외부 지역변수와 같은 이름의 매개변수를 허용하지 않는다.\n함수형 인터페이스는  라는 어노테이션을 붙일 수 있다.\n(컴파일러에서 추상메서드를 갖춘 인터페이스인지 검사, javadoc 페이지에서 해당 인터페이스가 함수형 인터페이스임을 알 수 있도록 한다)\n대부분의 메서드는 타입이 비슷하고 지네릭 메서드로 정의하면 반환 타입이 달라도 문제가 되지 않는다.\njava.util.function 패키지에는 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았으며 매번 함수형 인터페이스를\n정의하기 보다는 가능하면 이 패키지의 인터페이스를 활용한다.\n1.5 Function의 합성과 Predicate의 결합\nandThen : a.andThen(b) : a함수 적용 후 b함수 적용\ncompose : a.compose(b) : b함수 적용 후 a함수 적용\nidentity : 항등 함수 (잘 사용되지 않는 편이나 map()으로 변환 작업할 때 변환없이 그대로 처리하고자할 때 사용)\nand() : and 조건\nor() : or 조건\nisEqual() : 두 대상 비교\n메서드를 참조해서 매개변수의 정보 및 리턴 타입을 알아내어 람다식에서 불필요한 매개 변수를 제거하는 것이 목적.\n람다식의 매개 변수는 메서드의 매개값을 전달하는 역할만 하기 때문에 메서드 참조를 이용하면 깔끔하게 처리할 수 있다.\n(a, b) -> Math.max(a, b);\n하나의 메서드만 호출하는 람다식은 '클래스이름::메서드이름 또는 '참조변수::메서드이름'으로 바꿀 수 있다.\n생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다.\ns = () -> new MyClass();\nf = (i) -> new MyClass(i);\nf = x -> new int[x];\n다양한 데이터 소스를 표준화된 방법으로 다루기 위한 라이브러리이다.\n스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해놓았다.\n스트림을 이용하면, 배열이나 컬렉션 뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.\nString[] strArr = {\n문자열 배열 'strArr'과 같은 내용의 문자열을 저장하는 리스트 'strList'가 있을 때,\n각각의 데이터를 정렬하고 출력하는 방법\n(String str : strArr)\n(String str : strList)\n스트림을 사용한 코드가 더 간결하고 이해하기 쉬우면서 재사용성이 높다.\n스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단하게 처리할 수 있다.\n중간연산 : 연산결과가 스트림.\n최종연산 : 연산결과가 스트림이 아님.\n스트림의 요소를 소모하기 때문에\n모든 중간연산의 결과는 스트림이지만, 연산 전의 스트림과 같은 것은 아니다.\nString[] strArr = {\"dd\", \"aaa\", \"cc\", \"cc\", \"e\"}\n각 요소에 지정된 작업 수행\nOptional < T > max (Comparator\nOptional < T > min (Comparator\nOptional < T > findAny()\nOptional < T > findFirst()\nboolean allMatch(Pradicate < T > p)\nboolean anyMatch(Pradicate < T > p)\nboolean noneMatch(Pradicate < T > p)\n스트림의 모든 요소를 배열로 return\nreduce() : 스트림의 요소를 하나씩 줄여가면서(reducing) 계산한다.\ncollect() : 스트림의 요소를 수집한다.\n주로 요소를 그룹화하거나 결과를 컬렉션에 담아 반환하는데 사용된다.\n스트림은 데이터 소스를 변경하지 않는다.\n스트림은 데이터 소스로부터 데이터를 읽기만 할 뿐, 데이터소스를 변경하지 않는다.\n정렬된 결과가 필요할 경우, collect를 활용해서 컬렉션이나 배열에 담아 return할 수 있다.\n스트림은 한번 사용하면 닫혀서 다시 사용할 수 없다.\n필요하다면 스트림을 다시 생성해야 한다.\nException in thread \"main\" java.lang.IllegalStateException: stream has already been operated upon or closed\n스트림은 작업을 내부 반복으로 처리한다.\n내부 반복이란, 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다.\n는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 람다식을 데이터소스의 모든 요소에 적용한다.\n//수행할 작업을 매개변수로 받는다.\n최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다.\n스트림에 대해 sort()나 distinct()같은 중간 연산을 호출해도 즉각적으로 수행되지 않는다는 것이다.\n단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐\n최종연산이 수행되어서야 스트림의 요소들이 중간연산을 거치고 최종연산에 소모된다.\n오토박싱, 언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는\n일반적으로 Stream< Integer > 대신 IntStream을 사용하는 것이 더 효율적이고, IntStream에는 int타입으로 작업하는데 유용한 메서드들이 포함되어있다.\n앞서 13장에서 forkjoin framework으로 병렬처리하는 것에 대해 배웠는데, 스트림은 내부적으로 이 framework를 이용해서 연산을 자동적으로 병렬로 수행한다.\nparallel() 메서드를 호출하면 병렬로 연산이 수행되고, sequential() 메서드를 호출하면 병렬로 처리되지 않게 된다.\n모든 스트림은 기본적으로 병렬 스트림이 아니기 때문에 sequential() 메서드는 parallel()를 취소할 때만 사용한다.\nint sum = strStream.parallel().mapToInt(s -> s.length()).sum();\n컬렉션 클래스들은 모두 stream()메서드로 스트림을 생성할 수 있다.\nstream()은 해당 컬렉션을 소스로 하는 스트림을 반환한다.\nIntStream intStream = IntStream.range(\nIntStream intStream = IntStream.rangeClosed(\nint보다 큰 범위의 스트림을 생성하려면 LongStream을 사용하면 된다.\n난수를 생성하는데 사용하는 Random클래스에는 아래와 같은 메서드들이 포함되어있다.\n이 메서드들은 해당 타입의 난수들로 이루어진 스트림을 반환한다.\n// 5개의 요소만 출력\n// 크기가 5인 난수 스트림을 반환\nStream 클래스의 iterate(), generate()는 람다식을 매개변수로 받아서, 이\n람다식에 의해 계산되는 결과값들을 요소로\n하는 무한 스트림을 생성한다.\n: 이전 결과에 대해 종속적\n// 0, 2, 4, 6, ...\n: 이전 결과에 대해 독립적\n이전 결과를 이용해서 다음 요소를 계산하지 않는다.\niterate()와 generate()에 의해 생성된 스트림은 아래와 같이 기본형 스트림 타입의 참조변수로 다룰 수 없다.\nIntStream evenStream = Stream.iterate(\nDoubleStream randomStream = Stream.generate(Math::random);\n굳이 필요하다면, 아래와 같이 mapToInt()와 같은 메서드로 변환을 해야한다.\n// Path는 파일 또는 디렉토리\n요소가 하나도 없는 비어있는 스트림을 생성할 수도 있다.\n스트림에 연산을 수행한 결과가 하나도 없을 때 null보다는 빈 스트림을 return하는 것이 낫다.\nStream emptyStream = Stream.empty();\nString[] str1 = {\nString[] str2 = {\nstrs3 = Stream.concat(strs1, strs2);\nStream < T > distinct()\nStream < T > filter(Predicate < T > predicate\n조건에 안 맞는 요소 제외\nStream < T > limit(long maxSize)\nStream < T > skip(ling n)\nStream < T > peek(Consumer< T > action)\nStream < T > sorted()\n는 지정된 Comparator로 스트림을 정렬하는데, int 값을 반환하는 람다식을 사용하는 것도 가능하다.\n위의 문자열 스트림을 다양한 벙법으로 정렬한 후 forEach로 출력한 결과를 보여준다.\nString.CASE_INSENSITIVE_ORDER는 String클래스에 정의된 Comparator이다.\nJDK1.8부터 Comparator인터페이스에 static 메서드와 디폴트 메서드가 많이 추가되었는데, 이 메서드들을 이용하면 정렬이 쉬워진다.\n예를 들어 학생스트림을 반별, 성적순, 그리고 이름순으로 정렬하여 출력하려면 다음과 같이 한다.\n스트림의 요소에 저장된 값 중에서 원하는 필드만 뽑다내거나 특정 형태로 변환해야될 때 사용한다.\nStream < R > map (Function < T, R > mapper)\nDoubleStream mapToDouble (ToDoubleFunction < T > mapper)\nIntStream mapToInt (ToIntFunction < T > mapper)\nLongStream mapToLong (ToLongFunction < T > mapper)\n스트림의 요소를 숫자로 반환하는 경우, IntStream같은 기본형 스트림으로 변환하는 것이 더 유용할 수 있다.\n기본형 스트림은 숫자를 다루는 데 편리한 메서드들을 제공하기 때문이다.\nIntStream studentScoreStream = studentStream.mapToInt(Student::getTotalScore);\n추가적으로 이 메서드들은 최종연산이기 때문에 호출 후 스트림이 닫힌다.\n따라서 sum(), average() 를 연속해서 호출할 수 없다.\n이러한 경우에 스트림을 또 생성해야하므로 불편하다.\n그래서 summarystatics()라는 메서드가 따로 제공된다.\nIntSummaryStatistics stat = scoreStream.summaryStatistics();\n반대로 IntStream을 Stream < T >로 변환할 때는 mapToObj()를, Stream\n로 변환할 때는 boxed()를 사용한다.\n스트림의 요소가 배열이거나 map의 연산결과가 배열인경우, Stream < T [] >를 Stream < T >로 다루는 것이 더 편리할 때 flatMap()을 사용한다.\nfaltMap()은  map()과 달리 스트림의 스트림이 아닌 스트림으로 만들어준다.\nStream < R > flatMap (Function < T, Stream < R > > mapper)\nDoubleStream flatMapToDouble (Function< T, DoubleStream > mapper)\nIntStream flatMapToInt (Function< T, IntStream > mapper)\nLongStream flatMapToLong (Function< T, LongStream > mapper)\n2.4 Optional< T >와 OptionalInt\nOptional은 지네릭클래스로, T타입의 객체를 감싸는 래퍼클래스이다.\nOptional 타입의 객체에는 모든 타입의 참조변수를 담을 수 있다.\n최종 연산의 결과를 그냥 반환하는게 아니라 Optional객체에 담아서 반환을 하면, 반환된 결과가 null인지 매번 if문으로 체크하는 대신 Optional에 정의된 메서드를 통해 간단히 처리할 수 있다.\n참조변수의 값이 null일 가능성이 있으면 of()대신 ofNullable()을 사용해야 한다.\nof()는 매개변수의 값이 null이면 NullPointerException을 발생시키기 때문이다.\nOptional < T > 참조변수의 초기화\nOptional 객체의 값 가져오기\nString str1 = optVal.get();\n// optVal에 저장된 값을 반환.\nString str2 = optVal.orElse(\n// optVal에 저장된 값이 null일 때는, \"\"를 반환\nString str3 = optVal.orElseGet(String::\n// 람다식 사용가능 () -> new String()\nString str4 = optVal.orElseThrow(NullPointerException::\nOptional 객체의 값이 null이면 false, 아니면 true를 반환한다.\n// 값이 저장되어 있으면 true\n스트림의 요소를 하나씩 줄여가면서(reducing) 계산하고 최종결과를 반환한다.\n처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다.\n이 과정에서 스트림의 요소를 하나씩 소모하게 되며, 스트림의 모든 요소를 소모하게 되면 그 결과를 반환한다.\nOptional < T > reduce (BinaryOperator < T > accumulator)\n, (a,b) -> a+\n, (a,b) -> a+b);\n앞서 소개한 최종연산 count(),  sum() 등은 내부적으로 모두 reduce를 이용해서 작성된 것이다.\nCollector를 매개변수로 하는 스트림의 최종 연산이다.\n스트림연산에서 요소를 그룹화하거나 결과를 컬렉션에 담아 반환할 때 사용된다.\ncollect에 필요한 메서드를 정의해놓은 인터페이스이다.\n//T(요소)를 A에 누적한 다음 결과를 R로 변환해서 return\nSupplier < A >   supplier();\n//결과를 저장할 공간(A)을 제공\nBiConsumer < A, T > accumulator();\n//(sb, s) -> sb.append(s)\n//스트림의 요소를 수집(collect)할 방법을 제공\nBinaryOperator < A > combiner();\n//(sb1, sb2) -> sb1.append(sb2)\n//두 저장공간(A)을 결합할 방법을 제공(병렬 스트림)\nFunction < A, R > finisher();\n//변환할 필요가 없는 경우, x->x\n//컬렉터의 특성이 담긴 set return\n다양한 기능의 메소드를 제공한다.\n변환 : mapping(), toList(), toSet(), toMap(), toCollection(), ...\n통계 : counting(), summingInt(), averagingInt(), maxBy(), minBy(), summarizingInt(), ...\n문자열 결합 : joining()\nString studentNames = stuStream.map(Student::getName).collect(joining());\nString studentNames = stuStream.map(Student::getName).collect(joining(\nOptionalInt max = intStream.reduce(Integer::max);\n그룹화와 분할 : partitioningBy(), groupingBy(), collectingAndThen()\nprtitioningBy() : 스트림의 요소를 2분할 한다.\nMap < Boolean, Long > stuNumBySex = stuStream.collect(partitioningBy(Student::isMale));\n// 학생들을 성별로 분할\n// Map에서 남학생 목록을 얻는다.\nfemaleStudent = stuBySex.get(false); // Map에서 여학생 목록을 얻는다.\ngroupingBy() : 스트림의 요소를 그룹화한다.\n// 학생을 반별로 그룹화\nCollector인터페이스를 구현하는 클래스를 작성한다.\n//T(요소)를 A에 누적한 다음, 결과를 R로 변환해서 return\n컬렉터가 수행할 작업의 속성정보를 제공한다.\nCharacteristics.CONCURRENT      //병렬로 처리할 수 있는 작업\nCharacteristics.UNORDERED       //스트림 요소의 순서가 유지될 필요가 없는 작업\nSet < Characteristics > characteristics() {\n지정할 특성이 없으면 빈 set을 return한다.\n문자열 스트림의 모든 요소를 연결하는 컬렉터이다.\nSupplier< StringBuilder > supplier() {\nBiConsumer< StringBuilder, String > accumulator() {\n(sb, s) -> sb.append(s);\nFunction< StringBuilder, String > supplier() {\nBinaryOperator< StringBuilder > combiner() {\n(sb1, sb2) -> sb1.append(sb2);\nSet< Characteristics > characteristics() {\nString result = strStream.collect("
  },
  {
    "chapter": 14,
    "title": "Chapter 15 입출력(I/O)",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter15.html",
    "content": "컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것\n자바에서 입출력을 수행하기 위해 두 대상을 연결하고 데이터를 운반하는데 사용되는 연결통로\n먼저 보낸 데이터를 먼저 받게 되어 있으며 중간에 건너뜀 없이 연속적으로 데이터를 주고 받는다.\n1.3 바이트기반 스트림 - InputStream, OutputStream\n스트림은 바이트단위로 데이터를 전송하며 입출력 대상에 따라 다음과 같은 입출력스트림이 있다.\n[표15-1] 입력스트림과 출력 스트림\n이들은 모두 InputStream 또는 OutputStream의 자손들이며, 각각 읽고 쓰는데 필요한 추상메서드를 자신에 맞게 구현해 놓았다.\n자바에서는 java.io패키지를 통해서 많은 종류의 입출력관련 클래스들을 제공한다.\nabstract void write(int b)\nint read(byte[] b, int off, int len)\nvoid write(byte[] b, int off, int len)\n[표15-2] InputStream과 OutputStream에 정의된 읽기와 쓰기를 수행하는 메서드\nInputStream의 read()와 OutputStream의 write(int b)는 입출력의 대상에 따라 읽고 쓰는 방법이 다를 것이기 때문에 각 상황에 알맞게 구현하라는 의미에서 추상메서드로 정의되어 있다.\nread()와 write(int b)를 제외한 나머지 메서드들은 추상메서드가 아니니까 굳이 추상메서드인 read()와 write(int b)를 구현하지 않아도 이들을 사용하면 될 것이라고 생각할 수도 있겠지만 사실 추상메서드인 read()와 write(int b)를 이용해서 구현한 것들이기 때문에 read()와 write(int b)가 구현되어 있지 않으면 이들은 아무런 의미가 없다.\n// 입력스트림으로부터 1byte를 읽어서 반환한다.\n읽을 수 없으면 -1을 반환한다.\n// 입력스트림으로부터 len개의 byte를 읽어서 byte배열 b의 off위치부터 저장한다.\ni=offl i < off + len; i++) {\n// read()를 호출해서 데이터를 읽어서 배열을 채운다.\n// 입력스트림으로부터 byte배열 b의 크기만큼 데이터를 읽어서 배열 b에 저장한다.\n이 코드는 InputStream의 실제 소스코드의 일부를 이해하기 쉽게 약간 변경한 것인데, 여기서 read(byte[] b, int off, int len)의 코드를 보면 read()를 호출하는 것을 알 수 있다.\n메서드는 선언부만 알고 있어도 호출이 가능하기 때문에, 추상메서드를 호출하는 코드를 작성할 수 있다.\n결론적으로 read()는 반드시 구현되어야하는 핵심적인 메서드이고, read()없이는 read(byte[] b, int off, int len)와 read(byte[] b)는 의미가 없다는 것을 확인할 수 있다.\n실제 데이터를 주고받는 스트림이 아니기 때문에 데이터를 입출력할 수 있는 기능은 없지만, 스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있다.\n예를 들어 test.txt라는 파일을 읽기위해 FileInputStream을 사용할 때, 입력 성능을 향상시키기 위해 버퍼를 사용하는 보조스트림인 BufferedInputStream을 사용하는 코드는 다음과 같다.\n// 먼저 기반스트림을 생성한다.\n// 기반스트림을 이용해서 보조스트림을 생성한다.\n// 보조스트림인 BufferedInputStream으로부터 데이터를 읽는다.\n코드 상으로는 보조스트림인 BufferedInputStream이 입력 기능을 수행하는 것처럼 보이지만, 실제 입력기능은 BufferedInputStream과 연결된 FileInputStream이 수행하고, 보조 스트립인 BufferedInputStream은 버퍼만을 제공한다.\n버퍼를 사용한 입출력과 사용하지 않은 입출력간의 성능차이는 상당하기 때문에 대부분의 경우에 버퍼를 이용한 보조스트림을 사용한다.\n필터를 이용한 입출력 처리\n버퍼를 이용한 입출력 성능향상\nint, float와 같은 기본형 단위(primitive type)로 데이터를 처리하는 기능\n두 개의 스트림을 하나로 연결\n읽어 온 데이터의 라인 번호를 카운트(JDK1.1부터 LineNumberReader로 대체)\n데이터를 객체 단위로 읽고 쓰는데 사용.\n주로 파일을 이용하며 객체 직렬화와 관련 있음\n버퍼를 이용하며, 추가적인 print관련 기능(print, printf, println메서드)\n버퍼를 이용해서 읽어 온 데이터를 다시 되돌리는 기능(unread, push back to buffer)\n1.5 문자기반 스트림 - Reader, Writer\njava에서는 한 문자를 의미하는 char형이 1byte가 아니라 2byte이기 때문에 바이트기반의 스트림으로 2byte인 문자를 처리하는 데는 어려움이 있다.\n이 점을 보완하기 위해서 문자기반의 스트림이 제공된다.\n문자데이터를 입출력할 때는 바이트기반 스트림 대신 문자기반 스트림을 사용하자.\n바이트기반 스트림과 문자기반 스트림의 읽기 쓰기에 사용되는 메서드를 비교하면 byte배열 대신 char배열을 사용한다는 것과 추상메서드로 선언된 메서드의 종류가 다르다.\n보조스트림 역시 문자기반 보조스트림이 존재하며 사용목적과 방식은 바이트 기반과 다르지 않다.\n모든 바이트기반의 스트림의 조상이며 다양한 메소드가 선언되어 있다.\n스트림의 종류에 따라서 mark()와 reset()을 사용하여 이미 읽은 데이터를 되돌려서 다시 읽을 수 있다.\n이 기능을 지원하는 스트림인지 확인하는 markSupported()를 통해서 알 수 있다.\nflush()는 버퍼가 있는 출력스트림의 경우에만 의미가 있으며, OutputSteream에 정의된 flush()는 아무런 일도 하지 않는다.\n프로그램이 종료될 때, 사용하고 닫지 않은 스트림을 JVM이 자동적으로 닫아 주기는 하지만, 스트림을 사용해서 모든 작업을 마치고 난 후에는 close()를 호출해서 반드시 닫아주어야 한다.\n그러나 ByteArrayInputStream과 같이 메모리를 사용하는 스트림과 System.in, System.out과 같은 표준 입출력 스트림은 닫아 주지 않아도 된다.\n메모리, 즉 바이트배열에 데이터를 입출력 하는데 사용되는 스트림이다.\n스트림의 종류가 달라도 읽고 쓰는 방법은 동일하므로 아래 예제를 통해서 스트림에 읽고 쓰는 방법을 잘 익혀보자.\n[] inSrc = {\n// 읽어 올 수 있는 데이터의 크기 반환\n// 읽어 온 데이터의 개수를 반환\n// 읽어 온 만큼만 write\n// Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n// temp :[8, 9, 6, 7]\n// Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n파일에 입출력을 하기 위한 스트림\n[예제15-5] 커맨드라인으로부터 입력받은 파일의 내용을 읽어서 그대로 화면에 출력하는 예제\nInputStream/OutputStream의 자손이면서 모든 보조스트림의 조상으로 자체적으로 입출력을 수행할 수 없기 때문에 기반 스트림이 필요하여 FilterInputStream/FilterOutputStream은 상속을 통해 원하는 작업을 수행하도록 읽고 쓰는 메서드를 오버라이딩해야 한다.\n생성자 FilterInputStream(InputStream in)는 접근 제어자가 protected이기 때문에 FilterInputStream의 인스턴스를 생성해서 사용할 수 없고 상속을 통해서 오버라이딩되어야 한다.\nFilterInputStrem/FilterOutputStream을 상속받아서 기반스트림에 보조기능을 추가한 보조스트림 클래스는 다음과 같다.\nFilterInputStream의 자손 - BufferedInputStream, DataInputStream, PushbackInputStream 등\nFilterOutputStream의 자손 - BufferedInputStream, DataOutputStream, PrintStream 등\n스트림의 입출력 효율을 높이기 위해 버퍼를 사용하는 보조스트림으로 한 바이트씩 입출력하는 것보다는 버퍼(바이트 배열)를 이용해서 한 번에 여러 바이트를 입출력하는 것이 빠르기 때문에 대부분의 입출력 작업에 사용된다.\nBufferedInputStream은 입력소스로 부터 버퍼 크기만큼의 데이터를 읽어다 자신의 내부 버퍼에 저장하고 프로그램에서는 버퍼에 저장된 데이터를 읽으며, 다 읽고 그 다음 데이터를 읽기 위해 read메서드가 호출되면, BufferedInputStream은 입력소스로부터 다시 버퍼크기 만큼의 데이터를 읽어다 버퍼에 저장하는 작업을 반복한다.\nBufferedOutputStream 역시 버퍼를 이용해서 출력소스와 작업을 하게 되는데 프로그램에서 write메서드를 이용한 출력이 BufferedOutputStream의 버퍼에 저장된다.\n버퍼가 가득 차면, 그 때 버퍼의 모든 내용을 출력소스에 출력한다.\n버퍼가 가득 찼을 때만 출력소스에 출력을 하기 때문에, 마지막 출력부분이 출력소스에 쓰이지 못하고 BufferedOutputStream의 버퍼에 남아있는 채로 프로그램이 종료될 수 있다는 점을 주의해야 한다.\n그래서 프로그램에서 모든 출력작업을 마친 후 BufferedOutputStream에 close()나 flush()를 호출해서 마지막에 버퍼에 있는 모든 내용이 출력소스에 출력되도록 해야 한다.\n데이터를 읽고 쓰는데 있어서 byte단위가 아닌, 8가지 기본 자료형의 단위로 읽고 쓰기 가능\n예제 15-8을 실행해서 만들어진 sample.dat를 읽어서 화면에 출력하는 예제이다.\nsample.dat파일로부터 데이터를 읽어올 때 아무런 변환이나 자릿수를 셀 필요없이 단순히 readInt()와 같이 읽어올 데이터의 타입에 맞는 메서드를 사용하기만 하면 된다.\n여러 개의 입력스트림을 연속적으로 연결해서 하나의 스트림으로부터 데이터를 읽는 것과 같이 처리할 수 있도록 도와준다.\n큰 파일을 여러개의 작은 파일로 나누었다가 하나의 파일로 합치는 것과 같은 작업을 수행할 때 사용하면 좋을 것이다.\nEnumeration에 저장된 순서대로 입력스트림을 하나의 스트림으로 연결한다.\nSequenceInputStream(InputStream s1, InputStream s2)\n두 개의 입력스트림을 하나로 연결한다.\nVector files = new Vector();\nSequenceInputStream in = new SequenceInputStream(files.elements());\nFileInputStream file1 = new FileInputStream(\"file.001\");\nFileInputStream file2 = new FileInputStream(\"file.002\");\nSequenceInputStream in = new SequenceInputStream(file1, file2);\n데이터를 기반스트림에 다양한 형태로 출력할 수 있는 print, println, printf와 같은 메서드를 오버로딩하여 제공\nPrintStream과 거의 같은 기능을 갖는 PrintWrite가 JDK1.1에서 부터 추가되었는데 보다 다양한 문자를 처리하는데 적합하기 때문에 가능하면 PrintWriter를 사용하는 것이 좋다.\nchar 배열을 사용한 문자기반의 스트림 제공.\nReader/Writer의 인코딩에 따라 한번에 읽는 크기가 달라질 수 있다.\nFile로부터 Text 데이터를 읽고 쓰는데 사용된다.\n주로 쓰레드 간에 데이터를 주고 받을 때 사용된다.\nPipedReader/PipedWriter 는 문자기반의 스트림 형태의 Pipe의 내용을 읽거나 쓰는 용도이다.\n//do something with data...\nStringReader/Writer는 입출력 대상이 메모리인 스트림이다.\nStringReader는 문자열 데이터를 Reader 형태로 변환해준다.\n문자열 데이터를 오직 Reader를 기반으로 접근하게 변환이 필요할 경우 유용한다.\nBufferedReader/BufferedWriter 버퍼를 이용해서 입출력의 효율을 높일 수 있게 해주는 역할을 한다.\nThe BufferedReader will read a block of characters from the FileReader (typically into a char array).\nEach character returned from read() is thus returned from this internal array.\nWhen the array is fully read the BufferedReader reads a new block of data into the array etc.\nbufferedReader의 버퍼사이즈를 정할 수 있다.\nIt is best to use buffer sizes that are multiples of 1024 bytes.\nString line = bufferedReader.readLine();\nByte 기반 스트림을 문자기반 스트림으로 연결시켜주는 역할을 한다.\n주로 파일이나 네트워트 연결로부터 Byte로 제공되는 Text를 문자기반(char)로 읽고 쓰기를 할 경우에 많이 쓰인다.\n주의) char 값의 정수를 리턴한다.\n자바 IO패키지는 source로 부터 raw한 데이터를 읽고 raw한 데이터를 destination에 쓰는 것.\nSource --> Program --> Destination\n주요 io 클래스 관계\n6.1 표준입출력 - System.in, System.out, System.err\n위의 세 스트림은 JVM이 시작할때 초기화가 되므로 직접 초기화를 할 필요가 없다.\nSystem.in 은 콘솔의 키보드 인풋에 연결된 inputStream이다.\n콘솔로 데이터를 내보는 역할을 한다.\nSystem.out과 비슷하지만 일반적으로 에러메세지를 내보낼때 사용된다.\n6.2 표준입출력의 대상변경 - setOut(), setErr(), setIn()\nInputStream으로 System.in, OutputStream으로 System.out, System.err의 읽기/쓰기를 새로우 스트림으로 변경할 수 있다.\n입력과 출력을 하나의 클래스로 파일에 대한 입력/출력을 모두 할 수 있게 설계된 클래스.\n가장 큰 장점은 파일의 어느 위치에나 읽기/쓰기가 가능하다는 점이다.\n생성자의 두번쨰 'rw'는 RandomAccessFile의 mode 값이다.\nFile 클래스로 통해 파일과 디렉토리를 다룰 수 있도록 제공한다\nFile클래스는 파일과 파일의 메타데이터의 접근하는 기능만 제공한다.\n만약 파일의 내용을 읽기/쓰기 기능을 원한다면 file Stream을 이용해야한다.\n만약 NIO를 사용한다면 파일에 대한 접근은 java.nio.FileChannel를 사용해야한다.\nFile 객체 생성시 실제 파일이 없어도 예외가 나지 않고 정상적으로 생성된다.\nMove로 사용할 수 있음.\nString[] fileNames = file.list();\nFile[]   files = file.listFiles();\n직렬화란 객체를 데이터 스트림으로 만드는 것을 뜻한다.\n객체에 저장된 데이터를 스트림에 쓰기위해 연속적인(serial) 데이터로 변환하는 것을 말한다.\n자바 오브젝트를 쓰고(Serialization) 읽기(Deserializetion) 하기 위해선 Serializable 인터페이스를 구현(선언)해야한다.\nObjectInputStream/ObjectOutputStream은 raw 한 byte를 읽는거 대신, InputStream/OutputStream을 통해 자바 오브젝트를 읽을 수 있도록 해준다.\nMyClass object = (MyClass) objectInputStream.readObject();\n7.3 직렬화가 가능한 클래스 만들기 - Serializable, transient\n직렬화가 가능한 클래스를 만드는 방법은 Serializable 인터페이스를 원하는 클래스에 구현(선언)하면 된다.\npassword와 같은 직렬화하지 않을 멤버변수 앞에 transient 를 붙이면 된다.\n7.4 직렬화가능한 클래스의 버전관리\n직렬화된 객체를 역직렬화할 떄는 직렬화 했을 떄와 같은 클래스를 사용해야한다.\n하지만 클래스의 내용이 변경된 경우 역직렬화에 실패한다.\n//public String address = \"\";\nstatic 변수나 transient가 붙은 인스턴스변수는 직렬화에 영향을 미치지 않는다.\nIn today's world (2015 and forward) many Java projects serialize Java objects using different mechanisms than the Java serialization mechanism.\nFor instance, Java objects are serialized into JSON, BSON or other more optimized binary formats.\nThis has the advantage of the objects also being readable by non-Java applications.\nFor instance, JavaScript running in a web browser can natively serialize and deserialize objects to and from JSON."
  },
  {
    "chapter": 15,
    "title": "Chapter 16 네트워킹(Networking)",
    "url": "https://rebeccacho.gitbooks.io/java-study-group/content/chapter16.html",
    "content": "네트워킹(networking)이란 두 대 이상의 컴퓨터를 케이블로 연결하여 네트워크network)를 구성하는 것을 말한다\n'클라이언트/서버는 컴퓨터간의 관계를 역할로 구분하는 개념이다 서버(server)는 서비스를 제공하는 컴퓨터(service provider)이고 클라이언트(client)는 서비스를 사용하는 컴퓨터(service user)가 된다.\n네트워크를 구성할 때 전용서버를 두는 것을 서버기반모델 이라고 하고 각 클라이언트가 서버역할을 동시에 수행하는 것을 P2P모델 이라고 한다\n서버는 제공하는 서비스의 종류에 따라 파일서버 메일서버, 어플리케이션 서버 등이 있다\n안정적인 서비스의 제공이 가능하다\n서버구축 및 운용비용을 절감할 수 있다\n공유 데이터의 관리와 보안이 용이 하다\n자원의 활용을 극대화 할 수 있다\nIP주소는 컴퓨터를 네트워크 상에서 구별하는데 사용되는 고유한 값이며 4byte(32 bit)의 정수로 구성되어 있다\nIP주소는 네트워크주소와 호스트 주소로 누눌 수 있으며 네트워크 주소가 같다는 것은 두 호스트가 같은 네트워크에 포함되어 있다는 것을 의미한다\nIP Address에 Subnet Mask를 ''연산을 해주면 네트워크 주소를 알 수 있다\n192  168  10  100\n255  255  255  0\n자바에서는 IP주소를 다루기 위한 클래스로 InetAddress를 제공한다\n[] ipAddr = ip.getAddress();\n; i < ipAddr.length; i++) {\nresult += (ipAddr[i] <\n\"getAddress() + 256 :\"\n; i < ipArr.length; i++) {\ngetAddress() :[117, 52, 2, 25]\ngetAddress() + 256 :117.52.2.25.\n1.4 URL(Uniform Resource Location)\nURL은 인터넷에 존재하는 여러 서버들이 제공하는 자원에 접근할 수 있는 주소를 표현하기 위한것\n'프로토콜//호스트명:포트번호/경로명/파일명?쿼리스트링' 형태로 이루어져 있다\n프로토콜 자원에 접근하기 위해 서버와 통신하는데 사용되는 통신규약(http)\n호스트명 자원을 제공하는 서버의 이름(www.javachobo.com)\n포트번호 통신에 사용되는 서버의 포트번호(80)\n경로명 접근하려는 자원이 저장된 서버상의 위치(/sample)\n파일명 접근하려는 자원의 이름(hello.html)\n참조(anchor) URL에서 ''이후의 부분(index1)\nURLConnection은 어플리케이션과 URL간의 통신연결을 나타내는 클래스의 최상위 클래스로 추상클래스이다.\nURLConnection을 상속받아 구현한 클래스로는 HttpURLConnection과 JarURLConnection이 있으며 URL의 프로토콜이 http프로토콜이라면 openConnection()은 Http URLConnection을 반환한다.\n((line = input.readLine()) !=\n데이터가 문자데이터 이기 때문에 BefferedReader를 사용함\nurl.openStream()은 url.openConnectino().getInputStream() 과 같다\n( (ch=in.read()) != -\nHelloworld.class        Helloworld.java         Java                    Test.iml                javajungsuk.zip         out                     src\n텍스트가 아닌 이진 데이터를 읽어서 파일에 저장하는 예제\n네트워크의 양방향 통신에서 양쪽 끝단으로, TCP/IP 단에서 구분할 수 있는 하나의 포트 번호를 가진다.\njava.net 패키지가 소켓 프로그래밍 클래스들을 제공한다.\nTCP와 UDP 모두 TCP/IP 프로토콜에 포함되어있는 프로토콜로, OSI 7계층의 전송 계층(transport layer)에 해당하는 프로토콜이다.\n연결 기반, 1:1 통신\n비연결기반, 1:1 / 1:n / n:n 통신\n바이트 단위로 전송, 신뢰성 기반: 전송 순서 보존 / 수신 여부 확인\n데이터 단위로 전송, 신뢰성이 없다\nServerSocket으로 특정 포트로 소켓을 연다.\n서버의 IP 주소와 포트로 Socket으로 소켓을 만들어 서버에 연결 요청을 한다.\n클라이언트의 연결 요청을 받으면 Socket으로 소켓을 만들어 클라이언트의 소켓과 연결한다.\n연결된 각자의 소켓을 이용해 통신을 한다.\n여러 소켓이 포트 하나를 공유할 수 있지만, 서버소켓은 포트 하나를 독점한다.\n소켓은 입력스트림과 출력스트림을 가지고 상대방 소켓과 서로 교차연결해 데이터를 주고받는다.\nSocket socket = serverSocket.accept();\n// 클라이언트의 연결 요청을 받아 통신용 소켓을 만든다.\n연결지향이 아니므로 ServerSocket이 따로 필요하지 않다.\n소켓은 DatagramSocket를 사용해 만들어 DatagramPacket에 데이터를 담아 통신한다.\nDatagramPacket에는 헤더와 데이터가 있으며 헤더에 수신할 상대방의 정보(주소와 포트)를 저장한다.\n// (데이터, 데이터 길이) - 받을 패킷 만들기\n// 클라이언트는 포트를 지정하지 않는다.\nInetAddress serverAddress = InetAddress.getByName(\n// (데이터, 데이터 길이, 주소, 포트) - 보낼 패킷 만들기"
  }
]